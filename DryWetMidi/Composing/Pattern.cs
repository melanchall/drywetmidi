using System;
using System.Collections.Generic;
using System.Linq;
using Melanchall.DryWetMidi.Common;
using Melanchall.DryWetMidi.Core;
using Melanchall.DryWetMidi.Interaction;

namespace Melanchall.DryWetMidi.Composing
{
    /// <summary>
    /// Represents a musical pattern represented as a sequence of actions to create a musical composition.
    /// </summary>
    /// <remarks>
    /// <para>Pattern allows to represent musical composition as a set of actions like 'note' or 'program change'.
    /// In other words, it allows to create MIDI file in more musical manner.</para>
    /// <para>There are two ways to get an instance of the <see cref="Pattern"/>:</para>
    /// <list type="bullet">
    /// <item>
    /// <description>Build a pattern from scratch with fluent API provided by <see cref="PatternBuilder"/>.</description>
    /// </item>
    /// <item>
    /// <description>Use one of extension methods within <see cref="PatternUtilities"/> to create pattern
    /// by processing existing one.</description>
    /// </item>
    /// </list>
    /// You can see examples of building musical compositions in <see href="xref:a_composing_pattern"> the corresponding article</see>.
    /// </remarks>
    public sealed class Pattern
    {
        #region Constructor

        internal Pattern(IEnumerable<PatternAction> actions)
        {
            Actions = actions;
        }

        #endregion

        #region Properties

        internal IEnumerable<PatternAction> Actions { get; }

        #endregion

        #region Methods

        /// <summary>
        /// Exports the current <see cref="Pattern"/> to track chunk.
        /// </summary>
        /// <param name="tempoMap">Tempo map to process pattern data according with.</param>
        /// <param name="channel">Channel of notes that will be generated by pattern.</param>
        /// <returns>The <see cref="TrackChunk"/> containing notes events generated by the current <see cref="Pattern"/>.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="tempoMap"/> is <c>null</c>.</exception>
        public TrackChunk ToTrackChunk(TempoMap tempoMap, FourBitNumber channel)
        {
            ThrowIfArgument.IsNull(nameof(tempoMap), tempoMap);

            var context = new PatternContext(tempoMap, channel);
            var result = InvokeActions(0, context);

            return ((IEnumerable<ITimedObject>)result.Events ?? Enumerable.Empty<TimedEvent>())
                .Concat(result.Notes ?? Enumerable.Empty<Note>())
                .ToTrackChunk();
        }

        /// <summary>
        /// Exports the current <see cref="Pattern"/> to track chunk using zero channel.
        /// </summary>
        /// <param name="tempoMap">Tempo map to process pattern data according with.</param>
        /// <returns>The <see cref="TrackChunk"/> containing notes events generated by the current <see cref="Pattern"/>.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="tempoMap"/> is <c>null</c>.</exception>
        public TrackChunk ToTrackChunk(TempoMap tempoMap)
        {
            return ToTrackChunk(tempoMap, FourBitNumber.MinValue);
        }

        /// <summary>
        /// Exports the current <see cref="Pattern"/> to MIDI file.
        /// </summary>
        /// <param name="tempoMap">Tempo map to process pattern data according with.</param>
        /// <param name="channel">Channel of notes that will be generated by pattern.</param>
        /// <returns>The <see cref="MidiFile"/> containing notes events generated by the current <see cref="Pattern"/>.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="tempoMap"/> is <c>null</c>.</exception>
        public MidiFile ToFile(TempoMap tempoMap, FourBitNumber channel)
        {
            ThrowIfArgument.IsNull(nameof(tempoMap), tempoMap);

            var trackChunk = ToTrackChunk(tempoMap, channel);

            var midiFile = new MidiFile(trackChunk);
            midiFile.ReplaceTempoMap(tempoMap);

            return midiFile;
        }

        /// <summary>
        /// Exports the current <see cref="Pattern"/> to MIDI file using zero channel.
        /// </summary>
        /// <param name="tempoMap">Tempo map to process pattern data according with.</param>
        /// <returns>The <see cref="MidiFile"/> containing notes events generated by the current <see cref="Pattern"/>.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="tempoMap"/> is <c>null</c>.</exception>
        public MidiFile ToFile(TempoMap tempoMap)
        {
            return ToFile(tempoMap, FourBitNumber.MinValue);
        }

        /// <summary>
        /// Clones pattern by creating a copy of it.
        /// </summary>
        /// <returns>Copy of the pattern containing all actions from original one.</returns>
        public Pattern Clone()
        {
            return new Pattern(Actions.Select(a => a.Clone()).ToList());
        }

        internal PatternActionResult InvokeActions(long time, PatternContext context)
        {
            var notes = new List<Note>();
            var events = new List<TimedEvent>();

            foreach (var action in Actions)
            {
                var actionResult = action.Invoke(time, context);

                var newTime = actionResult.Time;
                if (newTime != null)
                    time = newTime.Value;

                var addedNotes = actionResult.Notes;
                if (addedNotes != null)
                    notes.AddRange(addedNotes);

                var addedEvents = actionResult.Events;
                if (addedEvents != null)
                    events.AddRange(addedEvents);
            }

            return new PatternActionResult(time, notes, events);
        }

        #endregion
    }
}
