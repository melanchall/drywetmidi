<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title>Getting objects | DryWetMIDI </title>
      <meta name="viewport" content="width=device-width">
      <meta name="title" content="Getting objects | DryWetMIDI ">
    
    
      <link rel="shortcut icon" href="../../images/favicon.png">
      <link rel="stylesheet" href="../../styles/docfx.vendor.min.css">
      <link rel="stylesheet" href="../../styles/docfx.css">
      <link rel="stylesheet" href="../../styles/main.css">
      <meta property="docfx:navrel" content="../../toc.html">
      <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../images/logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">

        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first=First data-prev=Previous data-next=Next data-last=Last></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="a_getting_objects">
<h1 id="getting-objects">Getting objects</h1>

<p>This article describes ways to get different objects (like <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.TimedEvent.html">timed events</a> or <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.Note.html">notes</a>) from MIDI files, track chunks and collections of another objects.</p>
<h2 id="gettimedevents">GetTimedEvents</h2>
<p><code>TimedEvent</code> is the basic MIDI object we will describe here. It's just a MIDI event along with its absolute time within a MIDI file or track chunk. To get all timed events in a MIDI file, you can just call <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.TimedEventsManagingUtilities.html#Melanchall_DryWetMidi_Interaction_TimedEventsManagingUtilities_GetTimedEvents_">GetTimedEvents</a> method:</p>
<pre><code class="lang-csharp">using System;
using Melanchall.DryWetMidi.Core;
using Melanchall.DryWetMidi.Interaction;

namespace DwmExamples
{
    class Program
    {
        static void Main(string[] args)
        {
            var midiFile = MidiFile.Read(&quot;My Great Song.mid&quot;);
            var timedEvents = midiFile.GetTimedEvents();

            Console.WriteLine($&quot;{timedEvents.Count} timed events found.&quot;);
        }
    }
}
</code></pre>
<p>Please examine the <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.TimedEventsManagingUtilities.html">TimedEventsManagingUtilities</a> class to see other <code>GetTimedEvents</code> overloads.</p>
<h2 id="getnotes">GetNotes</h2>
<p>There is the <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.NotesManagingUtilities.html">NotesManagingUtilities</a> class which provides useful methods <code>GetNotes</code> to get notes from a MIDI file or track chunk. For example, you can get notes a MIDI file contains with this code:</p>
<pre><code class="lang-csharp">using System;
using Melanchall.DryWetMidi.Common;
using Melanchall.DryWetMidi.Core;
using Melanchall.DryWetMidi.Interaction;

namespace DwmExamples
{
    class Program
    {
        static void Main(string[] args)
        {
            var midiFile = new MidiFile(
                new TrackChunk(
                    new NoteOnEvent(),
                    new NoteOffEvent(),
                    new NoteOnEvent((SevenBitNumber)70, (SevenBitNumber)50)
                    {
                        Channel = (FourBitNumber)5,
                        DeltaTime = 10
                    },
                    new NoteOffEvent((SevenBitNumber)70, (SevenBitNumber)30)
                    {
                        Channel = (FourBitNumber)5,
                        DeltaTime = 70
                    }));

            Console.WriteLine(&quot;Notes:&quot;);

            foreach (var note in midiFile.GetNotes())
            {
                Console.Write($@&quot;
note {note} (note number = {note.NoteNumber})
  time = {note.Time}
  length = {note.Length}
  velocity = {note.Velocity}
  off velocity = {note.OffVelocity}&quot;);
            }

            Console.ReadKey();
        }
    }
}
</code></pre>
<p>Running the program, we'll see following output:</p>
<pre><code class="lang-text">Notes:

note C-1 (note number = 0)
  time = 0
  length = 0
  velocity = 0
  off velocity = 0
note A#4 (note number = 70)
  time = 10
  length = 70
  velocity = 50
  off velocity = 30
</code></pre>
<p>Please examine <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.NotesManagingUtilities.html">NotesManagingUtilities</a> class to see other <code>GetNotes</code> overloads.</p>
<h3 id="settings">Settings</h3>
<p>All <code>GetNotes</code> overloads can accept <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.NoteDetectionSettings.html">NoteDetectionSettings</a> as a parameter. Via this parameter you can adjust the process of notes building.</p>
<p>More than that, notes are built on top of timed events. So you can pass <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.TimedEventDetectionSettings.html">TimedEventDetectionSettings</a> as a separate parameter to control how underlying MIDI events will be constructed.</p>
<p>Let's see each setting of the <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.NoteDetectionSettings.html">NoteDetectionSettings</a> in detail.</p>
<h4 id="notestartdetectionpolicy"><code>NoteStartDetectionPolicy</code></h4>
<p>The <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.NoteDetectionSettings.html#Melanchall_DryWetMidi_Interaction_NoteDetectionSettings_NoteStartDetectionPolicy">NoteStartDetectionPolicy</a> property defines how the start event of a note should be found in case of overlapping notes with the same note number and channel. The default value is <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.NoteStartDetectionPolicy.html#Melanchall_DryWetMidi_Interaction_NoteStartDetectionPolicy_FirstNoteOn">NoteStartDetectionPolicy.FirstNoteOn</a>.</p>
<p>To understand how this policy works let's take a look at the following events sequence:</p>
<p><img src="images/Getting-objects-NoteStartDetectionPolicy-Initial.png" alt="NoteStartDetectionPolicy-Initial"></p>
<p>where empty circle and filled one mean <em>Note On</em> and <em>Note Off</em> events correspondingly; cross means any other event. So we have two overlapped notes here (we assume all note events have the same note number and channel).</p>
<p>If we set <code>NoteStartDetectionPolicy</code> to <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.NoteStartDetectionPolicy.html#Melanchall_DryWetMidi_Interaction_NoteStartDetectionPolicy_FirstNoteOn">NoteStartDetectionPolicy.FirstNoteOn</a>, notes will be constructed in following way:</p>
<p><img src="images/Getting-objects-NoteStartDetectionPolicy-FirstNoteOn.png" alt="NoteStartDetectionPolicy-FirstNoteOn"></p>
<p>So every <em>Note Off</em> event will be combined with the <strong>first</strong> free <em>Note On</em> event into a note (events are processed one by one consecutively). But if set <code>NoteStartDetectionPolicy</code> to <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.NoteStartDetectionPolicy.html#Melanchall_DryWetMidi_Interaction_NoteStartDetectionPolicy_LastNoteOn">NoteStartDetectionPolicy.LastNoteOn</a>, we'll get another picture:</p>
<p><img src="images/Getting-objects-NoteStartDetectionPolicy-LastNoteOn.png" alt="NoteStartDetectionPolicy-LastNoteOn"></p>
<p>So <em>Note Off</em> events will be combined with the <strong>last</strong> free <em>Note On</em> event into a note.</p>
<h2 id="getchords">GetChords</h2>
<p>There is the <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.ChordsManagingUtilities.html">ChordsManagingUtilities</a> class which provides useful methods <code>GetChords</code> to get notes from a MIDI file or track chunk. For example, you can get chords a MIDI file contains with this code:</p>
<pre><code class="lang-csharp">using System;
using Melanchall.DryWetMidi.Common;
using Melanchall.DryWetMidi.Core;
using Melanchall.DryWetMidi.Interaction;

namespace DwmExamples
{
    class Program
    {
        static void Main(string[] args)
        {
            var midiFile = new MidiFile(
                new TrackChunk(
                    new NoteOnEvent(),
                    new NoteOffEvent(),
                    new NoteOnEvent
                    {
                        Channel = (FourBitNumber)5,
                        DeltaTime = 10
                    },
                    new NoteOffEvent
                    {
                        Channel = (FourBitNumber)5
                    },
                    new NoteOnEvent((SevenBitNumber)70, (SevenBitNumber)50)
                    {
                        Channel = (FourBitNumber)5
                    },
                    new NoteOffEvent((SevenBitNumber)70, (SevenBitNumber)30)
                    {
                        Channel = (FourBitNumber)5,
                        DeltaTime = 70
                    }));

            Console.WriteLine(&quot;Chords:&quot;);

            foreach (var chord in midiFile.GetChords())
            {
                Console.Write($@&quot;
chord
  channel = {chord.Channel}
  time = {chord.Time}
  length = {chord.Length}
  notes:&quot;);

                foreach (var note in chord.Notes)
                {
                    Console.Write($@&quot;
  note {note} (note number = {note.NoteNumber})
    channel = {note.Channel}
    time = {note.Time}
    length = {note.Length}
    velocity = {note.Velocity}
    off velocity = {note.OffVelocity}&quot;);
                }
            }

            Console.ReadKey();
        }
    }
}
</code></pre>
<p>Running the program, we'll see following output:</p>
<pre><code class="lang-text">Chords:

chord
  channel = 0
  time = 0
  length = 0
  notes:
  note C-1 (note number = 0)
    channel = 0
    time = 0
    length = 0
    velocity = 0
    off velocity = 0
chord
  channel = 5
  time = 10
  length = 70
  notes:
  note C-1 (note number = 0)
    channel = 5
    time = 10
    length = 0
    velocity = 0
    off velocity = 0
  note A#4 (note number = 70)
    channel = 5
    time = 10
    length = 70
    velocity = 50
    off velocity = 30
</code></pre>
<p>Please examine the <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.ChordsManagingUtilities.html">ChordsManagingUtilities</a> class to see other <code>GetChords</code> overloads.</p>
<h3 id="settings-1">Settings</h3>
<p>All <code>GetChords</code> overloads can accept <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.ChordDetectionSettings.html">ChordDetectionSettings</a> as a parameter. Via this parameter you can adjust the process of chord building.</p>
<p>Also note that chords are built on top of notes. So to build chords we need to build notes. The process of notes building is adjustable via <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.NoteDetectionSettings.html">NoteDetectionSettings</a> which you can pass to the methods too. Properties of the <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.NoteDetectionSettings.html">NoteDetectionSettings</a> are described in detail <a href="#settings">above</a>.</p>
<p>More than that, notes are built on top of timed events as described <a href="#settings">above</a>. So you can pass <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.TimedEventDetectionSettings.html">TimedEventDetectionSettings</a> too.</p>
<p>Let's see each setting of the <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.ChordDetectionSettings.html">ChordDetectionSettings</a> in detail.</p>
<h4 id="notestolerance"><code>NotesTolerance</code></h4>
<p>The <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.ChordDetectionSettings.html#Melanchall_DryWetMidi_Interaction_ChordDetectionSettings_NotesTolerance">NotesTolerance</a> property defines the maximum distance of notes from the start of the first note of a chord. Notes within this tolerance will be included in a chord. The default value is <code>0</code>.</p>
<p>To understand how this property works let's take a look at the following notes (cross means any non-note event):</p>
<p><img src="images/Getting-objects-NotesTolerance-Initial.png" alt="NotesTolerance-Initial"></p>
<p>If we set notes tolerance to <code>0</code> (which is default value), we'll get three different chords (each of one note):</p>
<p><img src="images/Getting-objects-NotesTolerance-0.png" alt="NotesTolerance-0"></p>
<p>Different colors denote different chords. If we set notes tolerance to <code>1</code>, we'll get two chords:</p>
<p><img src="images/Getting-objects-NotesTolerance-1.png" alt="NotesTolerance-1"></p>
<p>With tolerance of <code>2</code> we'll finally get a single chord:</p>
<p><img src="images/Getting-objects-NotesTolerance-2.png" alt="NotesTolerance-2"></p>
<h4 id="notesmincount"><code>NotesMinCount</code></h4>
<p>The <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.ChordDetectionSettings.html#Melanchall_DryWetMidi_Interaction_ChordDetectionSettings_NotesMinCount">NotesMinCount</a> property defines the minimum count of notes a chord can contain. So if the count of simultaneously sounding notes is less than this value, they won't make up a chord. The default value is <code>1</code> which means a single note can be turned to a chord.</p>
<p>To understand how this property works let's take a look at the following notes (cross means any non-note event):</p>
<p><img src="images/Getting-objects-NotesMinCount-Initial.png" alt="NotesMinCount-Initial"></p>
<p>So we have three notes. For simplicity we'll assume that <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.ChordDetectionSettings.html#Melanchall_DryWetMidi_Interaction_ChordDetectionSettings_NotesTolerance">NotesTolerance</a> is <code>0</code> (default value). If we set notes min count to <code>1</code> (which is default value), we'll get two different chords:</p>
<p><img src="images/Getting-objects-NotesMinCount-1.png" alt="NotesMinCount-1"></p>
<p>If we set notes min count to <code>2</code>, we'll get only one chord:</p>
<p><img src="images/Getting-objects-NotesMinCount-2.png" alt="NotesMinCount-2"></p>
<p>Last note will not be turned into a chord because the count of notes for a chord will be <code>1</code> which is less than the specified minimum count. With minimum count of notes of <code>3</code> we'll get no chords:</p>
<p><img src="images/Getting-objects-NotesMinCount-3.png" alt="NotesMinCount-3"></p>
<p>First possible chord will contain two notes and the second chord will contain one note. In both cases the count of notes is less than the specified minimum count.</p>
<h2 id="getobjects">GetObjects</h2>
<p>All methods we saw before return a collection of objects of the <strong>same type</strong>. So you can get only either notes or chords or timed events. To highlight the problem, let's take a look at the following events sequence:</p>
<p><img src="images/Getting-objects-GetObjects-Initial.png" alt="GetObjects-Initial"></p>
<p>where empty circle and filled one mean <em>Note On</em> and <em>Note Off</em> events correspondingly; cross means any other event. We assume all note events have the same note number and channel.</p>
<p>With <code>GetTimedEvents</code> we'll just get all these events as is. <code>GetNotes</code> will give us only notes:</p>
<p><img src="images/Getting-objects-GetObjects-GetNotes.png" alt="GetObjects-GetNotes"></p>
<p><code>GetChords</code> will return only chords (single one in this example):</p>
<p><img src="images/Getting-objects-GetObjects-GetChords.png" alt="GetObjects-GetChords"></p>
<p>So if we run following simple program:</p>
<pre><code class="lang-csharp">using System;
using System.Collections.Generic;
using Melanchall.DryWetMidi.Core;
using Melanchall.DryWetMidi.Interaction;

namespace DwmExamples
{
    class Program
    {
        static void Main(string[] args)
        {
            var midiFile = new MidiFile(
                new TrackChunk(
                    new TextEvent(&quot;1&quot;),
                    new NoteOnEvent { DeltaTime = 1 },
                    new TextEvent(&quot;2&quot;) { DeltaTime = 1 },
                    new NoteOffEvent { DeltaTime = 1 },
                    new TextEvent(&quot;3&quot;) { DeltaTime = 1 },
                    new NoteOnEvent { DeltaTime = 1 },
                    new TextEvent(&quot;4&quot;) { DeltaTime = 1 },
                    new NoteOffEvent { DeltaTime = 1 },
                    new TextEvent(&quot;5&quot;) { DeltaTime = 1 },
                    new NoteOnEvent { DeltaTime = 1 },
                    new TextEvent(&quot;6&quot;)),
                new TrackChunk(
                    new TextEvent(&quot;A&quot;),
                    new TextEvent(&quot;B&quot;) { DeltaTime = 1 },
                    new TextEvent(&quot;C&quot;) { DeltaTime = 1 },
                    new TextEvent(&quot;D&quot;) { DeltaTime = 1 },
                    new TextEvent(&quot;E&quot;) { DeltaTime = 1 },
                    new NoteOnEvent { DeltaTime = 1 },
                    new TextEvent(&quot;F&quot;) { DeltaTime = 1 },
                    new NoteOffEvent { DeltaTime = 1 },
                    new TextEvent(&quot;G&quot;) { DeltaTime = 1 },
                    new TextEvent(&quot;H&quot;) { DeltaTime = 1 },
                    new TextEvent(&quot;I&quot;)));

            Console.WriteLine(&quot;Getting timed events...&quot;);
            WriteTimedObjects(midiFile.GetTimedEvents());
            Console.WriteLine(&quot;Getting notes...&quot;);
            WriteTimedObjects(midiFile.GetNotes());
            Console.WriteLine(&quot;Getting chords...&quot;);
            WriteTimedObjects(midiFile.GetChords(new ChordDetectionSettings
            {
                NotesMinCount = 2
            }));

            Console.ReadKey();
        }

        private static void WriteTimedObjects&lt;TObject&gt;(ICollection&lt;TObject&gt; timedObjects)
            where TObject : ITimedObject
        {
            foreach (var timedObject in timedObjects)
            {
                Console.WriteLine($&quot;[{timedObject.GetType().Name}] {timedObject} (time = {timedObject.Time})&quot;);
            }
        }
    }
}
</code></pre>
<p>we'll get this output:</p>
<pre><code class="lang-text">Getting timed events...
[TimedEvent] Event at 0: Text (1) (time = 0)
[TimedEvent] Event at 0: Text (A) (time = 0)
[TimedEvent] Event at 1: Note On [0] (0, 0) (time = 1)
[TimedEvent] Event at 1: Text (B) (time = 1)
[TimedEvent] Event at 2: Text (2) (time = 2)
[TimedEvent] Event at 2: Text (C) (time = 2)
[TimedEvent] Event at 3: Note Off [0] (0, 0) (time = 3)
[TimedEvent] Event at 3: Text (D) (time = 3)
[TimedEvent] Event at 4: Text (3) (time = 4)
[TimedEvent] Event at 4: Text (E) (time = 4)
[TimedEvent] Event at 5: Note On [0] (0, 0) (time = 5)
[TimedEvent] Event at 5: Note On [0] (0, 0) (time = 5)
[TimedEvent] Event at 6: Text (4) (time = 6)
[TimedEvent] Event at 6: Text (F) (time = 6)
[TimedEvent] Event at 7: Note Off [0] (0, 0) (time = 7)
[TimedEvent] Event at 7: Note Off [0] (0, 0) (time = 7)
[TimedEvent] Event at 8: Text (5) (time = 8)
[TimedEvent] Event at 8: Text (G) (time = 8)
[TimedEvent] Event at 9: Note On [0] (0, 0) (time = 9)
[TimedEvent] Event at 9: Text (6) (time = 9)
[TimedEvent] Event at 9: Text (H) (time = 9)
[TimedEvent] Event at 9: Text (I) (time = 9)
Getting notes...
[Note] C-1 (time = 1)
[Note] C-1 (time = 5)
[Note] C-1 (time = 5)
Getting chords...
[Chord] C-1 C-1 (time = 5)
</code></pre>
<p>As you can see there is a &quot;free&quot; <em>Note On</em> event without corresponding <em>Note Off</em> one so we can't build a note for it. What if we want to get all possible notes and all remaining timed events? DryWetMIDI provides the <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.GetObjectsUtilities.html">GetObjectsUtilities</a> class which contains <code>GetObjects</code> methods (for the same MIDI structures as previous methods). We can change printing part of the program above to:</p>
<pre><code class="lang-csharp">Console.WriteLine(&quot;Getting notes and timed events...&quot;);
WriteTimedObjects(midiFile.GetObjects(ObjectType.Note | ObjectType.TimedEvent));
</code></pre>
<p>which will give us following output:</p>
<pre><code class="lang-text">Getting notes and timed events...
[TimedEvent] Event at 0: Text (1) (time = 0)
[TimedEvent] Event at 0: Text (A) (time = 0)
[Note] C-1 (time = 1)
[TimedEvent] Event at 1: Text (B) (time = 1)
[TimedEvent] Event at 2: Text (2) (time = 2)
[TimedEvent] Event at 2: Text (C) (time = 2)
[TimedEvent] Event at 3: Text (D) (time = 3)
[TimedEvent] Event at 4: Text (3) (time = 4)
[TimedEvent] Event at 4: Text (E) (time = 4)
[Note] C-1 (time = 5)
[Note] C-1 (time = 5)
[TimedEvent] Event at 6: Text (4) (time = 6)
[TimedEvent] Event at 6: Text (F) (time = 6)
[TimedEvent] Event at 8: Text (5) (time = 8)
[TimedEvent] Event at 8: Text (G) (time = 8)
[TimedEvent] Event at 9: Note On [0] (0, 0) (time = 9)
[TimedEvent] Event at 9: Text (6) (time = 9)
[TimedEvent] Event at 9: Text (H) (time = 9)
[TimedEvent] Event at 9: Text (I) (time = 9)
</code></pre>
<p>So all note events that build up a note were turned into instances of <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.Note.html">Note</a>, and all remaining events (including &quot;free&quot; <em>Note On</em> one) were returned as instances of <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.TimedEvent.html">TimedEvent</a>.</p>
<p>We can go further and collect all possible chords, notes and timed events:</p>
<pre><code class="lang-csharp">Console.WriteLine(&quot;Getting chords, notes and timed events...&quot;);
WriteTimedObjects(midiFile.GetObjects(
    ObjectType.Chord | ObjectType.Note | ObjectType.TimedEvent,
    new ObjectDetectionSettings
    {
        ChordDetectionSettings = new ChordDetectionSettings
        {
            NotesMinCount = 2
        }
    }));
</code></pre>
<p>which will give us following output:</p>
<pre><code class="lang-text">Getting chords, notes and timed events...
[TimedEvent] Event at 0: Text (1) (time = 0)
[TimedEvent] Event at 0: Text (A) (time = 0)
[Note] C-1 (time = 1)
[TimedEvent] Event at 1: Text (B) (time = 1)
[TimedEvent] Event at 2: Text (2) (time = 2)
[TimedEvent] Event at 2: Text (C) (time = 2)
[TimedEvent] Event at 3: Text (D) (time = 3)
[TimedEvent] Event at 4: Text (3) (time = 4)
[TimedEvent] Event at 4: Text (E) (time = 4)
[Chord] C-1 C-1 (time = 5)
[TimedEvent] Event at 6: Text (4) (time = 6)
[TimedEvent] Event at 6: Text (F) (time = 6)
[TimedEvent] Event at 8: Text (5) (time = 8)
[TimedEvent] Event at 8: Text (G) (time = 8)
[TimedEvent] Event at 9: Note On [0] (0, 0) (time = 9)
[TimedEvent] Event at 9: Text (6) (time = 9)
[TimedEvent] Event at 9: Text (H) (time = 9)
[TimedEvent] Event at 9: Text (I) (time = 9)
</code></pre>
<p>Or in visual representation:</p>
<p><img src="images/Getting-objects-GetObjects-GetChordsAndNotesAndTimedEvents.png" alt="GetObjects-GetChordsAndNotesAndTimedEvents"></p>
<p>Currently <code>GetObjects</code> can build objects of the following types:</p>
<ul>
<li><a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.TimedEvent.html">TimedEvent</a></li>
<li><a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.Note.html">Note</a></li>
<li><a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.Chord.html">Chord</a></li>
<li><a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.Rest.html">Rest</a></li>
</ul>
<h2 id="rests">Rests</h2>
<p>To build rests you need to use extension methods from the <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.RestsUtilities.html">RestsUtilities</a> class.</p>
<p>If you take a look into the class, you'll discover two methods – <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.RestsUtilities.html#Melanchall_DryWetMidi_Interaction_RestsUtilities_WithRests_">WithRests</a> and <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.RestsUtilities.html#Melanchall_DryWetMidi_Interaction_RestsUtilities_GetRests_">GetRests</a>. The first one adds rests to a collection of objects you've passed to the method. The second method returns rests only.</p>
<p>It will be much easier to understand how rests building works with examples. So let's look at the <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.RestsUtilities.html#Melanchall_DryWetMidi_Interaction_RestsUtilities_WithRests_">WithRests</a> (there is no great value to discuss <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.RestsUtilities.html#Melanchall_DryWetMidi_Interaction_RestsUtilities_GetRests_">GetRests</a> since it works in the same way but just returns rests only).</p>
<p>Supposing we have following notes (with two different note numbers on two different channels):</p>
<p><img src="images/Getting-objects-GetObjects-Rests-Initial.png" alt="GetObjects-Rests-Initial"></p>
<p>Using following code:</p>
<pre><code class="lang-csharp">var notesAndRests = notes
    .WithRests(new RestDetectionSettings
    {
        KeySelector = obj =&gt; 0
    });
</code></pre>
<p>we'll get only one rest:</p>
<p><img src="images/Getting-objects-GetObjects-Rests-NoSeparation.png" alt="GetObjects-Rests-NoSeparation"></p>
<p>An important concept we need to discuss is <strong>key selection</strong>. Key is used to calculate rests. Rests are always calculated only between objects with the same key. If an object with different key is encountered, rests will be calculated for that key.</p>
<p>In the code above we're saying: <em>The key of each object is 0</em>. So for the rests building algorithm all objects are the same, there is no difference between channels and note numbers, for example. So rests will be constructed only at spaces where there are no notes at all (with any channels and any note numbers).</p>
<p>Also please take a look at the predefined key selectors available via constants of the <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.RestDetectionSettings.html">RestDetectionSettings</a>. We can rewrite code above:</p>
<pre><code class="lang-csharp">var notesAndRests = notes
    .WithRests(RestDetectionSettings.NoNotes);
</code></pre>
<p>Using following code:</p>
<pre><code class="lang-csharp">var notesAndRests = notes
    .WithRests(new RestDetectionSettings
    {
        KeySelector = obj =&gt; (obj as Note)?.Channel
    });
</code></pre>
<p>we'll get three rests now:</p>
<p><img src="images/Getting-objects-GetObjects-Rests-SeparateByChannel.png" alt="GetObjects-Rests-SeparateByChannel"></p>
<p>So rests are separated by channels. Channel is the key of an object. Note number of a note doesn't matter, all numbers are treated as the same one. So rests will be constructed separately for each channel at spaces where there are no notes (with any note numbers).</p>
<p>The key for which a rest has been built will be stored in the <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.Rest.html#Melanchall_DryWetMidi_Interaction_Rest_Key">Key</a> property of <a class="xref" href="../../api/Melanchall.DryWetMidi.Interaction.Rest.html">Rest</a> class. <code>notesAndRests</code> is a collection containing both <code>notes</code> and calculated rests, and elements of this collection are sorted by their times.</p>
<p>Note that you can build rests for objects of different types. Why not get chords from a MIDI file and add rests between them?</p>
<pre><code class="lang-csharp">var chordsAndRests = midiFile
    .GetObjects(ObjectType.Chord)
    .WithRests(new RestDetectionSettings
    {
        KeySelector = obj =&gt; (obj as Chord)?.Channel
    });
</code></pre>
<p>And a couple of words about return value of the key selector. If <code>null</code> is returned, an object won't participate in rests building process. It allows you to have rests for desired objects only. For example:</p>
<pre><code class="lang-csharp">var notesAndChordsAndRests = midiFile
    .GetObjects(ObjectType.Note | ObjectType.Chord)
    .WithRests(new RestDetectionSettings
    {
        KeySelector = obj =&gt; (obj as Note)?.Channel
    });
</code></pre>
<p>Here we specify that rests will be built for notes only (key selector will return <code>null</code> for an object other than note). So the result collection will have chords, notes and rests between notes with channel as the key.</p>
<p>And a couple of additional examples with notes presented on the picture above.</p>
<p>Code:</p>
<pre><code class="lang-csharp">var notesAndRests = notes
    .WithRests(new RestDetectionSettings
    {
        KeySelector = obj =&gt; (obj as Note)?.NoteNumber
    });
</code></pre>
<p>Rests:</p>
<p><img src="images/Getting-objects-GetObjects-Rests-SeparateByNoteNumber.png" alt="GetObjects-Rests-SeparateByNoteNumber"></p>
<p>As you can see, rests now are separated by note number (channel doesn't matter). So rests will be constructed for each note number at spaces where there are no notes (with any channel).</p>
<p>Code:</p>
<pre><code class="lang-csharp">var notesAndRests = notes
    .WithRests(new RestDetectionSettings
    {
        KeySelector = obj =&gt; ((obj as Note)?.NoteNumber, (obj as Note)?.NoteNumber)
    });
</code></pre>
<p>Now we'll get rests at every &quot;free&quot; space (since the key is a pair of channel and note's number):</p>
<p><img src="images/Getting-objects-GetObjects-Rests-SeparateByChannelAndNoteNumber.png" alt="GetObjects-Rests-SeparateByChannelAndNoteNumber"></p>

</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In this article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
      2025 / Generated by <a href="https://dotnet.github.io/docfx">DocFX</a>
      
          </div>
        </div>
      </footer>
    </div>

    <script type="text/javascript" src="../../styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
