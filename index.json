{
  "articles/composing/Pattern.html": {
    "href": "articles/composing/Pattern.html",
    "title": "Pattern | DryWetMIDI",
    "keywords": "Pattern DryWetMIDI provides a way to create a MIDI file in more \"musical\" manner. The key class here is the PatternBuilder which allows to build a musical composition. PatternBuilder provides a fluent interface to program the music. For example, you can insert a note like this: using Melanchall.DryWetMidi.Composing; var patternBuilder = new PatternBuilder() // Insert the A4 note with length of 5/17 and velocity of 68 .Note(Octave.Get(4).A, new MusicalTimeSpan(5, 17), (SevenBitNumber)68) // Insert the G#3 note with default length and velocity .Note(Octave.Get(3).GSharp); In the example above the last Note method inserts a note with default length and velocity that can be set via corresponding methods at any moment: var patternBuilder = new PatternBuilder() .SetNoteLength(MusicalTimeSpan.Half) .SetVelocity((SevenBitNumber)50) // All the following notes will have half length and velocity of 50 .Note(Octave.Get(4).A) .Note(Note.Get(NoteName.B, 1)) .Note(-Interval.Two) .SetNoteLength(MusicalTimeSpan.Quarter) // All the following notes will have quarter length .Note(Octave.Get(2).A); Please take a look at entire API provided by PatternBuilder . Following example shows how to create first four bars of Beethoven's 'Moonlight Sonata': // Define a chord for bass part which is just an octave var bassChord = new[] { Interval.Twelve }; // Build the composition var pattern = new PatternBuilder() // The length of all main theme's notes within four first bars is // triplet eight so set it which will free us from necessity to specify // the length of each note explicitly .SetNoteLength(MusicalTimeSpan.Eighth.Triplet()) // Anchor current time (start of the pattern) to jump to it // when we'll start to program bass part .Anchor() // We will add notes relative to G#3. // Instead of Octave.Get(3).GSharp it is possible to use Note.Get(NoteName.GSharp, 3) .SetRootNote(Octave.Get(3).GSharp) // Add first three notes and repeat them seven times which will // give us two bars of the main theme // G#3 .Note(Interval.Zero) // +0 (G#3) .Note(Interval.Five) // +5 (C#4) .Note(Interval.Eight) // +8 (E4) .Repeat(3, 7) // repeat three previous notes seven times // Add notes of the next two bars // G#3 .Note(Interval.One) // +1 (A3) .Note(Interval.Five) // +5 (C#4) .Note(Interval.Eight) // +8 (E4) .Repeat(3, 1) // repeat three previous notes .Note(Interval.One) // +1 (A3) .Note(Interval.Six) // +6 (D4) .Note(Interval.Ten) // +10 (F#4) .Repeat(3, 1) // repeat three previous notes // reaching the end of third bar .Note(Interval.Zero) // +0 (G#3) .Note(Interval.Four) // +4 (C4) .Note(Interval.Ten) // +10 (F#4) .Note(Interval.Zero) // +0 (G#3) .Note(Interval.Five) // +5 (C#4) .Note(Interval.Eight) // +8 (E4) .Note(Interval.Zero) // +0 (G#3) .Note(Interval.Five) // +5 (C#4) .Note(Interval.Seven) // +7 (D#4) .Note(-Interval.Two) // -2 (F#3) .Note(Interval.Four) // +4 (C4) .Note(Interval.Seven) // +7 (D#4) // Now we will program bass part. To start adding notes from the // beginning of the pattern we need to move to the anchor we set // above .MoveToFirstAnchor() // First two chords have whole length .SetNoteLength(MusicalTimeSpan.Whole) // insert a chord relative to .Chord(bassChord, Octave.Get(2).CSharp) // C#2 (C#2, C#3) .Chord(bassChord, Octave.Get(1).B) // B1 (B1, B2) // Remaining four chords has half length .SetNoteLength(MusicalTimeSpan.Half) .Chord(bassChord, Octave.Get(1).A) // A1 (A1, A2) .Chord(bassChord, Octave.Get(1).FSharp) // F#1 (F#1, F#2) .Chord(bassChord, Octave.Get(1).GSharp) // G#1 (G#1, G#2) .Repeat() // repeat the previous chord // Build a pattern that can be then saved to a MIDI file .Build(); Build method returns an instance of Pattern . Pattern can be transformed or altered by methods in PatternUtilities . Pattern can be then saved to MidiFile (via ToFile method) or TrackChunk (via ToTrackChunk method). You need to provide a tempo map . Also you can optionally specify the channel that should be set to events. The default channel is 0 . Also please see Extension methods section of the Pattern API."
  },
  "articles/custom-data-structures/Custom-chunks.html": {
    "href": "articles/custom-data-structures/Custom-chunks.html",
    "title": "Custom chunks | DryWetMIDI",
    "keywords": "Custom chunks MIDI files are made up of chunks . Each chunk has a 4-character ID and a 32-bit length, which is the number of bytes in the chunk. This structure allows future or custom chunk types to be designed which may be easily ignored if encountered by a program written before a chunk type is introduced or if the program doesn't know about the type. DryWetMIDI allows you to implement custom chunks which can be written to a MIDI file and be read from it. For example, we want to design a chunk that will contain information about changes in whatever we want. A change is described by date (day, month, year) and comment . Let's create the class to store single change. public sealed class Change { public Change(DateTime date, string comment) { Date = date; Comment = comment; } public DateTime Date { get; } public string Comment { get; } } Now we are going to implement a custom chunk. Custom chunk class must be derived from the MidiChunk and must implement four abstract methods: ReadContent ; WriteContent ; GetContentSize ; Clone . Also the class must have parameterless constructor which calls constructor of the base class ( MidiChunk ) passing chunk's ID to it. ID is a 4-character string which will be Hstr for our chunk. ID of custom chunk should not be the same as one of standard chunks IDs. To get IDs of standard chunks you can call MidiChunk.GetStandardChunkIds . The class will look like this: public sealed class HistoryChunk : MidiChunk { private const string Id = \"Hstr\"; private readonly List<Change> _changes = new List<Change>(); public HistoryChunk() : base(Id) { } public void AddChange(DateTime dateTime, string comment) { _changes.Add(new Change(dateTime, comment)); } protected override void ReadContent(MidiReader reader, ReadingSettings settings, uint size) { throw new NotImplementedException(); } protected override void WriteContent(MidiWriter writer, WritingSettings settings) { throw new NotImplementedException(); } protected override uint GetContentSize(WritingSettings settings) { throw new NotImplementedException(); } public override MidiChunk Clone() { throw new NotImplementedException(); } } Before we will start to implement four methods mentioned above we need to determine the structure of change records according to which it should be read and written. Chunk's content will be started with the count of changes. We will write this count as variable-length quantity (VLQ) number. The count followed by change records. Each change is: one byte for day ; one byte for month ; two bytes for year ; VLQ number bytes representing size of bytes array which is encoded comment; bytes which represent encoded comment string. To store comments we will use Unicode encoding. Let's implement the ReadContent method: protected override void ReadContent(MidiReader reader, ReadingSettings settings, uint size) { // Read changes count var changesCount = reader.ReadVlqNumber(); for (int i = 0; i < changesCount; i++) { // Read date var day = reader.ReadByte(); var month = reader.ReadByte(); var year = reader.ReadWord(); // ushort // Read comment var commentLength = reader.ReadVlqNumber(); var commentBytes = reader.ReadBytes(commentLength); var comment = Encoding.Unicode.GetString(commentBytes); // Add change to changes list AddChange(new DateTime(year, month, day), comment); } } It is highly recommended that count of the bytes were read by this method is equal to the value passed to size parameter. To be able to write the chunk we need to implement WriteContent method: protected override void WriteContent(MidiWriter writer, WritingSettings settings) { // Write changes count writer.WriteVlqNumber(_changes.Count); foreach (var change in _changes) { // Write date var date = change.Date; writer.WriteByte((byte)date.Day); writer.WriteByte((byte)date.Month); writer.WriteWord((ushort)date.Year); // Write comment var comment = change.Comment; if (string.IsNullOrEmpty(comment)) { writer.WriteVlqNumber(0); continue; } var commentBytes = Encoding.Unicode.GetBytes(comment.ToCharArray()); writer.WriteVlqNumber(commentBytes.Length); writer.WriteBytes(commentBytes); } } Every chunk starts with ID and its size. DryWetMIDI calls GetContentSize method of the MidiChunk to write its return value as chunk's size. You must calculate real size of the chunk's content in order to programs which will be read a MIDI file with your custom chunk will be able to skip it by advancing position of the reader on this size. Let's implement GetContentSize : protected override uint GetContentSize(WritingSettings settings) { return (uint)( _changes.Count.GetVlqLength() + _changes.Select(c => { var commentLength = Encoding.Unicode.GetByteCount(c.Comment.ToCharArray()); return 4 /* 1 for day, 1 for month, 2 for year */ + commentLength.GetVlqLength() + commentLength; }) .DefaultIfEmpty() .Sum()); } Implementation of Clone method is pretty easy: public override MidiChunk Clone() { var result = new HistoryChunk(); result._changes.AddRange(_changes); return result; } That's all! Custom chunk is completely implemented. See code sample below to know how to read and write it: // Create a history chunk and populate it by some changes var historyChunk = new HistoryChunk(); historyChunk.AddChange(new DateTime(2017, 3, 23), \"Start the history!\"); historyChunk.AddChange(new DateTime(2156, 11, 3), \"Comment from the future.\"); historyChunk.AddChange(new DateTime(9999, 2, 12), null); // Add the chunk to an existing MIDI file var file = MidiFile.Read(\"My Great Song.mid\"); file.Chunks.Add(historyChunk); file.Write(\"My Great Song.mid\", true); // Read the file with our chunk var fileWithHistoryChunk = MidiFile.Read( \"My Great Song.mid\", new ReadingSettings { CustomChunkTypes = new ChunkTypesCollection { { typeof(HistoryChunk), \"Hstr\" } } }); var historyChunks = fileWithHistoryChunk.Chunks.OfType<HistoryChunk>(); If you don't provide information about your custom chunk in ReadingSettings , the chunks will be read as UnknownChunk ."
  },
  "articles/custom-data-structures/Custom-meta-events.html": {
    "href": "articles/custom-data-structures/Custom-meta-events.html",
    "title": "Custom meta events | DryWetMIDI",
    "keywords": "Custom meta events Meta events specify non-MIDI information useful to specific application. As with custom chunks , future or custom meta events may be designed. Format of meta events allows to programs which don't know about these new events to skip them without reading process failure. DryWetMIDI allows you to implement custom meta events which can be written to a MIDI file track chunk and be read from it. For example, let's create an event which will hold an image. Custom meta event must be derived from the MetaEvent and must implement four abstract methods: ReadContent ; WriteContent ; GetContentSize ; CloneEvent . Also a class must have parameterless constructor. public sealed class ImageEvent : MetaEvent { public ImageEvent() : base() { } public ImageEvent(Image image) : this() { Image = image; } public Image Image { get; set; } protected override void ReadContent(MidiReader reader, ReadingSettings settings, int size) { throw new NotImplementedException(); } protected override void WriteContent(MidiWriter writer, WritingSettings settings) { throw new NotImplementedException(); } protected override int GetContentSize(WritingSettings settings) { throw new NotImplementedException(); } protected override MidiEvent CloneEvent() { throw new NotImplementedException(); } } Now we implement methods mentioned above. Start from the ReadContent : protected override void ReadContent(MidiReader reader, ReadingSettings settings, int size) { if (size == 0) return; var imageBytes = reader.ReadBytes(size); var converter = new ImageConverter(); Image = (Image)converter.ConvertFrom(imageBytes); } Every meta event contains size of the event's content. Size is passed to ReadContent through size parameter so we know how much bytes we need to read in order to restore an image. Now let's implement WriteContent : protected override void WriteContent(MidiWriter writer, WritingSettings settings) { if (Image == null) return; var converter = new ImageConverter(); var imageBytes = (byte[])converter.ConvertTo(Image, typeof(byte[])); writer.WriteBytes(imageBytes); } Now we have to implement GetContentSize : protected override int GetContentSize(WritingSettings settings) { if (Image == null) return 0; var converter = new ImageConverter(); var imageBytes = (byte[])converter.ConvertTo(Image, typeof(byte[])); return imageBytes.Length; } Value returned by this method will be written to the event as its content size. To support cloning of an event we need to implement CloneEvent method: public override MidiEvent CloneEvent() { return new ImageEvent(Image?.Clone() as Image); } Custom meta event is completely implemented. In order to read and write it we must assign status byte to the event. You have to pick value from the [0x5F; 0x7E] range which will be the status byte of your event type. You can get status bytes of standard meta events via MetaEvent.GetStandardMetaEventStatusBytes . See code sample below to know how to read and write custom meta event: // Define collection of custom meta event types along with // corresponding status bytes. var customMetaEventTypes = new EventTypesCollection { { typeof(ImageEvent), 0x5F } }; // Write an image event to an existing file. var file = MidiFile.Read(\"My Great Song.mid\"); var trackChunk = file.Chunks.OfType<TrackChunk>().First(); var image = Image.FromFile(\"My image.jpg\"); var imageEvent = new ImageEvent(image); trackChunk.Events.Add(imageEvent); file.Write(\"My Great Song.mid\", true, MidiFileFormat.MultiTrack, new WritingSettings { CustomMetaEventTypes = customMetaEventTypes }); // Read a MIDI file with ImageEvent inside. // // Note that if you don't specify custom meta event through CustomMetaEventTypes // property of the ReadingSettings it will be read as UnknownMetaEvent. var updatedFile = MidiFile.Read( \"My Great Song.mid\", new ReadingSettings { CustomMetaEventTypes = customMetaEventTypes });"
  },
  "articles/dev/Manual-build.html": {
    "href": "articles/dev/Manual-build.html",
    "title": "Manual build | DryWetMIDI",
    "keywords": "Manual build This article describes how you can manually build the library from sources. Just follow the steps below: Select branch you want to build sources from ( master or develop ). Download sources with any method you want: via Code → Download ZIP button on GitHub, then extract archive; or git clone https://github.com/melanchall/drywetmidi.git ; or somehow else. Download native binaries required to work with MIDI devices and default playback: for master branch take DryWetMIDI.<release_number>-bin-native.zip archive from Releases (<release_number> is the number of the library release you want to build); for develop branch go to https://dev.azure.com/Melanchall/DryWetMIDI/_build/latest?definitionId=6&branchName=develop and download DryWetMIDI.<release_number>-bin-native.zip from Artifacts → Binaries . Extract the archive and place extracted files near <your_local_folder_with_repository>\\DryWetMidi\\Melanchall.DryWetMidi.csproj . Build the solution <your_local_folder_with_repository>\\Melanchall.DryWetMidi.sln . For build you can use any tool you want: dotnet CLI, Visual Studio, Rider and so on. The library uses \"new\" csproj format so your build tools should be modern enough. master branch contains code that the library releases built on. develop one is for current development so if you need the latest code, use this branch."
  },
  "articles/dev/Nativeless-package.html": {
    "href": "articles/dev/Nativeless-package.html",
    "title": "Nativeless package | DryWetMIDI",
    "keywords": "Nativeless package DryWetMIDI is shipped in two versions: Melanchall.DryWetMidi ; Melanchall.DryWetMidi.Nativeless . First one is the version containing all the features of the library and you should use it in most cases. But some things require platform-specific code which placed in native binaries packed along with the main library. If you've encountered problems with such code and you don't need API that depends on native binaries, you can use Melanchall.DryWetMidi.Nativeless package where such things are cut out. Following types are unavailable in the nativeless package: VirtualDevice ; DevicesWatcher ; DeviceAddedRemovedEventArgs ; MidiDevice ; InputDevice ; InputDeviceProperty ; MidiTimeCodeReceivedEventArgs ; OutputDevice ; OutputDeviceOption ; OutputDeviceProperty ; OutputDeviceTechnology ; TickGeneratorException ; HighPrecisionTickGenerator . Also default tick generator for Playback there is RegularPrecisionTickGenerator instead of HighPrecisionTickGenerator . Although built-in implementations of IInputDevice and IOutputDevice are unavailable in the nativeless package, you are still able to create your own implementations and use across the library API (in Playback for example)."
  },
  "articles/dev/Project-health.html": {
    "href": "articles/dev/Project-health.html",
    "title": "Project health | DryWetMIDI",
    "keywords": "Project health Here you can see \"health\" of the project in terms of test pipelines are passed or not. First of all, we need to define two subsets of the library API: Core API - it's all API except Multimedia one; in other words it's the API that is supported by .NET itself, so it can be run on any platform .NET Core / .NET supported. Multimedia API - it's platform-specific API that includes following key classes: InputDevice (more details in the InputDevice article); OutputDevice (more details in the OutputDevice article); VirtualDevice (more details in the VirtualDevice article); DevicesWatcher (more details in the DevicesWatcher article); HighPrecisionTickGenerator . Windows master develop macOS master develop Linux Multimedia API is not available for Linux . master develop Package integration Package integration tests check that NuGet package installed in .NET applications of different types works as expected. master develop"
  },
  "articles/dev/Using-in-Unity.html": {
    "href": "articles/dev/Using-in-Unity.html",
    "title": "Using in Unity | DryWetMIDI",
    "keywords": "Using in Unity This article describes how to integrate DryWetMIDI in a Unity project. You have two main ways: import the DryWetMIDI asset from the Unity Asset Store; install the library manually. There are also ways to import a NuGet package via 3d party tools (for example, NuGetForUnity ). Unity asset It's the simplest way. Just use built-in ways to import the official DryWetMIDI asset into your Unity project from the Asset Store. Manual installation Instruction below shows how to integrate full version of the DryWetMIDI into your Unity project manually. If you want to use nativeless version , just take archive with -nativeless suffix on the second step and skip third one. Create Melanchall folder in project's Assets folder and DryWetMIDI subfolder within the Melanchall one. Download the library main binary: for master branch take DryWetMIDI.<release_number>-bin-netstandard20.zip archive from Releases ( <release_number> is the number of the library release you want to take binaries of); for develop branch go to https://dev.azure.com/Melanchall/DryWetMIDI/_build/latest?definitionId=6&branchName=develop and download DryWetMIDI.<release_number>-bin-netstandard20.zip from Artifacts → Binaries . Download native binaries required to work with MIDI devices and default playback: for master branch take DryWetMIDI.<release_number>-bin-native.zip archive from Releases ; for develop branch go to https://dev.azure.com/Melanchall/DryWetMIDI/_build/latest?definitionId=6&branchName=develop and download DryWetMIDI.<release_number>-bin-native.zip from Artifacts → Binaries . ( master branch contains code that the library releases built on. develop one is for current development so if you need the latest API, use this branch) Extract archives into project's Assets → Melanchall → DryWetMIDI folder. Example Now you can use DryWetMIDI API in your Unity scripts. Following sample script (included in demo scene within the full DryWetMIDI package ) will create a MIDI file containing all possible notes with length of 1/8 and will play the file via Microsoft GS Wavetable Synth output device: using System; using System.Linq; using System.Text; using Melanchall.DryWetMidi.Common; using Melanchall.DryWetMidi.Composing; using Melanchall.DryWetMidi.Core; using Melanchall.DryWetMidi.Interaction; using Melanchall.DryWetMidi.Multimedia; using Melanchall.DryWetMidi.Standards; using UnityEngine; public class DemoScript : MonoBehaviour { private const string OutputDeviceName = \"Microsoft GS Wavetable Synth\"; private OutputDevice _outputDevice; private Playback _playback; private void Start() { InitializeOutputDevice(); var midiFile = CreateTestFile(); InitializeFilePlayback(midiFile); StartPlayback(); } private void OnApplicationQuit() { Debug.Log(\"Releasing playback and device...\"); if (_playback != null) { _playback.NotesPlaybackStarted -= OnNotesPlaybackStarted; _playback.NotesPlaybackFinished -= OnNotesPlaybackFinished; _playback.Dispose(); } if (_outputDevice != null) _outputDevice.Dispose(); Debug.Log(\"Playback and device released.\"); } private void InitializeOutputDevice() { Debug.Log($\"Initializing output device [{OutputDeviceName}]...\"); var allOutputDevices = OutputDevice.GetAll(); if (!allOutputDevices.Any(d => d.Name == OutputDeviceName)) { var allDevicesList = string.Join(Environment.NewLine, allOutputDevices.Select(d => $\" {d.Name}\")); Debug.Log($\"There is no [{OutputDeviceName}] device presented in the system. Here the list of all device:{Environment.NewLine}{allDevicesList}\"); return; } _outputDevice = OutputDevice.GetByName(OutputDeviceName); Debug.Log($\"Output device [{OutputDeviceName}] initialized.\"); } private MidiFile CreateTestFile() { Debug.Log(\"Creating test MIDI file...\"); var patternBuilder = new PatternBuilder() .SetNoteLength(MusicalTimeSpan.Eighth) .SetVelocity(SevenBitNumber.MaxValue) .ProgramChange(GeneralMidiProgram.Harpsichord); foreach (var noteNumber in SevenBitNumber.Values) { patternBuilder.Note(Melanchall.DryWetMidi.MusicTheory.Note.Get(noteNumber)); } var midiFile = patternBuilder.Build().ToFile(TempoMap.Default); Debug.Log(\"Test MIDI file created.\"); return midiFile; } private void InitializeFilePlayback(MidiFile midiFile) { Debug.Log(\"Initializing playback...\"); _playback = midiFile.GetPlayback(_outputDevice); _playback.Loop = true; _playback.NotesPlaybackStarted += OnNotesPlaybackStarted; _playback.NotesPlaybackFinished += OnNotesPlaybackFinished; Debug.Log($\"Output device [{OutputDeviceName}] initialized.\"); } private void StartPlayback() { Debug.Log(\"Starting playback...\"); _playback.Start(); } private void OnNotesPlaybackFinished(object sender, NotesEventArgs e) { LogNotes(\"Notes finished:\", e); } private void OnNotesPlaybackStarted(object sender, NotesEventArgs e) { LogNotes(\"Notes started:\", e); } private void LogNotes(string title, NotesEventArgs e) { var message = new StringBuilder() .AppendLine(title) .AppendLine(string.Join(Environment.NewLine, e.Notes.Select(n => $\" {n}\"))) .ToString(); Debug.Log(message.Trim()); } } Important Pay attention to OnApplicationQuit method. You should always take care about disposing MIDI devices. Without it all resources taken by the device will live until GC collect them. In case of Unity it means Unity may need be reopened to be able to use the same devices again (for example, on Windows)."
  },
  "articles/devices/Common-problems.html": {
    "href": "articles/devices/Common-problems.html",
    "title": "Common problems | DryWetMIDI",
    "keywords": "Common problems StartCoroutine can only be called from the main thread in Unity Sometimes you want to start Unity coroutine in a handler of EventReceived event of InputDevice . Your code can be executed on separate thread in these case. It can happen because of events are received by device on separate (system) thread. But UI related things like call of StartCoroutine can be executed on UI thread only. You can use the solution from here: https://stackoverflow.com/a/56715254 . Related question on StackOverflow: Catching and processing multiple keyboard inputs at once"
  },
  "articles/devices/Devices-connector.html": {
    "href": "articles/devices/Devices-connector.html",
    "title": "Devices connector | DryWetMIDI",
    "keywords": "Devices connector You can redirect MIDI events from input device to output device(s) using DevicesConnector class. To understand what input and output MIDI device is in DryWetMIDI, please read Overview article. Device connector connects an instance of the IInputDevice to one or multiple instances of the IOutputDevice . To get an instance of DevicesConnector class you can use either its constructor or Connect extension method on IInputDevice . In first case you need to call Connect method after you get DevicesConnector instance. In second case the method will be called automatically. Also you can call Disconnect at any time to disable connection between devices. The image below shows how devices will be connected in DryWetMIDI: Following small example shows basic usage of DevicesConnector : using Melanchall.DryWetMidi.Multimedia; // ... using (var inputDevice = InputDevice.GetByName(\"MIDI In\")) using (var outputDevice1 = OutputDevice.GetByName(\"MIDI Out 1\")) using (var outputDevice2 = OutputDevice.GetByName(\"MIDI Out 2\")) { var devicesConnector = new DevicesConnector(inputDevice, outputDevice1, outputDevice2) devicesConnector.Connect(); } So if a MIDI event will be received by MIDI In device, the event will be sent to both MIDI Out 1 and MIDI Out 2 . Don't forget to call StartEventsListening on input device to make sure EventReceived will be fired and MIDI event redirected to output devices. Read more in Input device article."
  },
  "articles/devices/Devices-watcher.html": {
    "href": "articles/devices/Devices-watcher.html",
    "title": "Devices watcher | DryWetMIDI",
    "keywords": "Devices watcher Important Watching devices available for macOS only. DryWetMIDI allows to track whether a MIDI device added to or removed from the system. There is DevicesWatcher class for that purpose. The class is singleton and you can get the instance with Instance property. DevicesWatcher provides two events: DeviceAdded and DeviceRemoved . First one will be fired when a MIDI device is added to the system, and second one - when a device removed from it. You can then cast device instance from the events arguments to InputDevice or OutputDevice . See following sample program: using System; using System.Threading; using Melanchall.DryWetMidi.Multimedia; namespace DwmExamples { class Program { static void Main(string[] args) { DevicesWatcher.Instance.DeviceAdded += OnDeviceAdded; DevicesWatcher.Instance.DeviceRemoved += OnDeviceRemoved; Console.WriteLine(\"Adding device...\"); var virtualDevice = VirtualDevice.Create(\"MyDevice\"); Thread.Sleep(500); // to get system time to see new device Console.WriteLine(\"Removing device...\"); virtualDevice.Dispose(); Console.ReadKey(); } private static void OnDeviceRemoved(object sender, DeviceAddedRemovedEventArgs e) { Console.WriteLine($\"Device removed: {e.Device.GetType()}\"); } private static void OnDeviceAdded(object sender, DeviceAddedRemovedEventArgs e) { Console.WriteLine($\"Device added: {e.Device.GetType()} ({e.Device.Name})\"); } } } Running the program we'll see following output: Adding device... Device added: Melanchall.DryWetMidi.Multimedia.InputDevice (MyDevice) Device added: Melanchall.DryWetMidi.Multimedia.OutputDevice (MyDevice) Removing device... Device removed: Melanchall.DryWetMidi.Multimedia.InputDevice Device removed: Melanchall.DryWetMidi.Multimedia.OutputDevice When device is added you can immediately interact with it using an instance from the DeviceAdded event's arguments. But an instance from the DeviceRemoved event's arguments is non-interactable, because device is removed and doesn't exist in the system anymore. Any attempt to call methods or properties on that instance will throw an exception: using System; using System.Threading; using Melanchall.DryWetMidi.Multimedia; namespace DwmExamples { class Program { static void Main(string[] args) { DevicesWatcher.Instance.DeviceRemoved += OnDeviceRemoved; var virtualDevice = VirtualDevice.Create(\"MyDevice\"); Thread.Sleep(500); // to get system time to see new device Console.WriteLine(\"Removing device...\"); virtualDevice.Dispose(); Console.ReadKey(); } private static void OnDeviceRemoved(object sender, DeviceAddedRemovedEventArgs e) { Console.WriteLine($\"Device removed. Getting its name...\"); var deviceName = e.Device.Name; } } } The progrum will be crashed with: Removing device... Device removed. Getting its name... Unhandled exception. System.InvalidOperationException: Operation can't be performed on removed device. But you can compare device instances via Equals to know whether two instances of MidiDevice are equal or not. Following example shows how you can get the name of a removed device via info about devices stored at the start of the program: using System; using System.Collections.Generic; using System.Linq; using System.Threading; using Melanchall.DryWetMidi.Multimedia; namespace DwmExamples { class Program { private static Dictionary<MidiDevice, string> _devicesNames; static void Main(string[] args) { DevicesWatcher.Instance.DeviceRemoved += OnDeviceRemoved; var virtualDevice = VirtualDevice.Create(\"MyDevice\"); Thread.Sleep(500); // to get system time to see new device _devicesNames = InputDevice.GetAll() .OfType<MidiDevice>() .Concat(OutputDevice.GetAll()) .ToDictionary(d => d, d => d.Name); Console.WriteLine(\"Removing device...\"); virtualDevice.Dispose(); Console.ReadKey(); } private static void OnDeviceRemoved(object sender, DeviceAddedRemovedEventArgs e) { Console.WriteLine($\"Device removed. Getting its name...\"); var deviceName = _devicesNames[e.Device]; Console.WriteLine($\"Name is {deviceName}\"); } } } Output is: Removing device... Device removed. Getting its name... Name is MyDevice Device removed. Getting its name... Name is MyDevice Device instances comparing can be useful in programs with GUI where you need update the list of available devices. So when a device is added, you just add it to the list. When some device is removed, you find corresponding item in the current list via Equals on device instances and remove that item. Important Checking for devices equality supported for macOS only. On Windows any call of Equals will just compare references."
  },
  "articles/devices/Input-device.html": {
    "href": "articles/devices/Input-device.html",
    "title": "Input device | DryWetMIDI",
    "keywords": "Input device In DryWetMIDI an input MIDI device is represented by IInputDevice interface. It allows to receive events from a MIDI device. To understand what an input MIDI device is in DryWetMIDI, please read Overview article. The library provides built-in implementation of IInputDevice : InputDevice class. To get an instance of InputDevice you can use either GetByName or GetByIndex static methods. ID of a MIDI device is a number from 0 to devices count minus one . To get count of input MIDI devices presented in the system there is the GetDevicesCount method. You can get all input MIDI devices with GetAll method. Important You can use InputDevice built-in implementation of IInputDevice on Windows and macOS only. Of course you can create your own implementation of IInputDevice as described in Custom input device section below. After an instance of InputDevice is obtained, call StartEventsListening to start listening incoming MIDI events going from an input MIDI device. If you don't need to listen for events anymore, call StopEventsListening . Also this method will be called automatically on Dispose . To check whether InputDevice is currently listening for events or not use IsListeningForEvents property. If an input device is listening for events, it will fire EventReceived event for each incoming MIDI event. Received MIDI event will be passed to event's handler. Small example (console app) that shows receiving MIDI data: using System; using Melanchall.DryWetMidi.Multimedia; namespace InputDeviceExample { class Program { private static IInputDevice _inputDevice; static void Main(string[] args) { _inputDevice = InputDevice.GetByName(\"Some MIDI device\"); _inputDevice.EventReceived += OnEventReceived; _inputDevice.StartEventsListening(); Console.WriteLine(\"Input device is listening for events. Press any key to exit...\"); Console.ReadKey(); (_inputDevice as IDisposable)?.Dispose(); } private static void OnEventReceived(object sender, MidiEventReceivedEventArgs e) { var midiDevice = (MidiDevice)sender; Console.WriteLine($\"Event received from '{midiDevice.Name}' at {DateTime.Now}: {e.Event}\"); } } } Important You should always take care about disposing an InputDevice , so use it inside using block or call Dispose manually. Without it all resources taken by the device will live until GC collect them via finalizer of the InputDevice . It means that sometimes you will not be able to use different instances of the same device across multiple applications or different pieces of a program. InputDevice has MidiTimeCodeReceived event which, by default, will be fired only when all MIDI Time Code components (separate MidiTimeCodeEvent events) are received forming hours:minutes:seconds:frames timestamp. You can turn this behavior off by setting RaiseMidiTimeCodeReceived to false . If an invalid channel , system common or system real-time or system exclusive event received, ErrorOccurred event will be fired with Data property of the exception filled with an information about the error. Custom input device You can create your own input device implementation and use it in your app. For example, let's create device that will listen for specific keyboard keys and report corresponding note via EventReceived event. Also we will control current octave with up arrow and down arrow increasing or decreasing octave number correspondingly. Following image shows the scheme of our device: Now we implement it: public sealed class KeyboardInputDevice : IInputDevice { public event EventHandler<MidiEventReceivedEventArgs> EventReceived; private static readonly Dictionary<ConsoleKey, NoteName> NotesNames = new Dictionary<ConsoleKey, NoteName> { [ConsoleKey.A] = NoteName.C, [ConsoleKey.W] = NoteName.CSharp, [ConsoleKey.S] = NoteName.D, [ConsoleKey.E] = NoteName.DSharp, [ConsoleKey.D] = NoteName.E, [ConsoleKey.F] = NoteName.F, [ConsoleKey.T] = NoteName.FSharp, [ConsoleKey.G] = NoteName.G, [ConsoleKey.Y] = NoteName.GSharp, [ConsoleKey.H] = NoteName.A, [ConsoleKey.U] = NoteName.ASharp, [ConsoleKey.J] = NoteName.B }; private readonly Thread _thread; private int _octaveNumber = 4; private SevenBitNumber? _currentNoteNumber; public KeyboardInputDevice() { _thread = new Thread(ListenEvents); } public bool IsListeningForEvents { get; private set; } public void StartEventsListening() { _thread.Start(); IsListeningForEvents = true; } public void StopEventsListening() { if (_currentNoteNumber != null) EventReceived?.Invoke(this, new MidiEventReceivedEventArgs( new NoteOffEvent(_currentNoteNumber.Value, SevenBitNumber.MinValue))); IsListeningForEvents = false; } public void Dispose() { } private void ListenEvents() { while (IsListeningForEvents) { var key = Console.ReadKey(true); if (!NotesNames.TryGetValue(key.Key, out var noteName)) { switch (key.Key) { case ConsoleKey.UpArrow: _octaveNumber++; Console.WriteLine($\"Octave is {_octaveNumber} now\"); break; case ConsoleKey.DownArrow: _octaveNumber--; Console.WriteLine($\"Octave is {_octaveNumber} now\"); break; case ConsoleKey.Escape: StopEventsListening(); Console.WriteLine(\"Listening stopped.\"); break; } continue; } var noteNumber = CalculateNoteNumber(noteName, _octaveNumber); if (!IsNoteNumberValid(noteNumber)) continue; if (_currentNoteNumber != null) EventReceived?.Invoke(this, new MidiEventReceivedEventArgs( new NoteOffEvent(_currentNoteNumber.Value, SevenBitNumber.MinValue))); EventReceived?.Invoke(this, new MidiEventReceivedEventArgs( new NoteOnEvent((SevenBitNumber)noteNumber, SevenBitNumber.MaxValue))); _currentNoteNumber = (SevenBitNumber)noteNumber; } } private static bool IsNoteNumberValid(int noteNumber) { return noteNumber >= SevenBitNumber.MinValue && noteNumber <= SevenBitNumber.MaxValue; } private static int CalculateNoteNumber(NoteName noteName, int octave) { return (octave + 1) * Octave.OctaveSize + (int)noteName; } } We can then use it for Recording or redirecting received notes to real output device to make them sound: var outputDevice = OutputDevice.GetByName(\"Microsoft GS Wavetable Synth\"); var devicesConnector = keyboardInputDevice.Connect(outputDevice);"
  },
  "articles/devices/Output-device.html": {
    "href": "articles/devices/Output-device.html",
    "title": "Output device | DryWetMIDI",
    "keywords": "Output device In DryWetMIDI an output MIDI device is represented by IOutputDevice interface. It allows to send events to a MIDI device. To understand what an output MIDI device is in DryWetMIDI, please read Overview article. The library provides built-in implementation of IOutputDevice : OutputDevice . To get an instance of OutputDevice you can use either GetByName or GetByIndex static methods. To retrieve count of output MIDI devices presented in the system there is the GetDevicesCount method. You can get all output MIDI devices with GetAll method: using System; using Melanchall.DryWetMidi.Multimedia; // ... foreach (var outputDevice in OutputDevice.GetAll()) { Console.WriteLine(outputDevice.Name); } Important You can use OutputDevice built-in implementation of IOutputDevice on Windows and macOS only. Of course you can create your own implementation of IOutputDevice as described in Custom output device section below. After an instance of OutputDevice is obtained, you can send MIDI events to device via SendEvent method. You cannot send meta events since such events can be inside a MIDI file only. If you pass an instance of meta event class, SendEvent will do nothing. EventSent event will be fired for each event sent with SendEvent (except meta events) holding the MIDI event sent. The value of DeltaTime property of MIDI events will be ignored, events will be sent to device immediately. To take delta-times into account, use Playback class. If you need to interrupt all currently sounding notes, call the TurnAllNotesOff method which will send Note Off events on all channels for all note numbers (kind of \"panic\" button on MIDI devices). Small example that shows sending MIDI data: using System; using Melanchall.DryWetMidi.Multimedia; using Melanchall.DryWetMidi.Core; // ... using (var outputDevice = OutputDevice.GetByName(\"Some MIDI device\")) { outputDevice.EventSent += OnEventSent; outputDevice.SendEvent(new NoteOnEvent()); outputDevice.SendEvent(new NoteOffEvent()); } // ... private void OnEventSent(object sender, MidiEventSentEventArgs e) { var midiDevice = (MidiDevice)sender; Console.WriteLine($\"Event sent to '{midiDevice.Name}' at {DateTime.Now}: {e.Event}\"); } Important You should always take care about disposing an OutputDevice , so use it inside using block or call Dispose manually. Without it all resources taken by the device will live until GC collect them via finalizer of the OutputDevice . It means that sometimes you will not be able to use different instances of the same device across multiple applications or different pieces of a program. First call of SendEvent method can take some time for allocating resources for device, so if you want to eliminate this operation on sending a MIDI event, you can call PrepareForEventsSending method before any MIDI event will be sent. Custom output device You can create your own output device implementation and use it in your app. For example, let's create super simple device that just outputs MIDI events to console: private sealed class ConsoleOutputDevice : IOutputDevice { public event EventHandler<MidiEventSentEventArgs> EventSent; public void PrepareForEventsSending() { } public void SendEvent(MidiEvent midiEvent) { Console.WriteLine(midiEvent); } public void Dispose() { } } You can then use this device, for example, for debug in Playback . Another one use case for custom output device is plugging some synth. So you create output device where SendEvent will redirect MIDI events to synth."
  },
  "articles/devices/Overview.html": {
    "href": "articles/devices/Overview.html",
    "title": "Overview | DryWetMIDI",
    "keywords": "Overview DryWetMIDI provides ability to send MIDI data to or receive it from MIDI devices. For that purpose there are following types: IInputDevice (see Input device ); IOutputDevice (see Output device ); DevicesConnector (see Devices connector ). The library provides implementations for both IInputDevice and IOutputDevice : InputDevice and OutputDevice correspondingly which represent MIDI devices visible by the operating system. Both classes implement IDisposable interface so you should always dispose them to free devices for using by another applications. Important You can use InputDevice and OutputDevice built-in implementations of IInputDevice and IOutputDevice on Windows and macOS only. Of course you can create your own implementations of IInputDevice and IOutputDevice . All classes that interact with devices work with interfaces mentioned above, so you can create custom implementation of your devices (see examples in Input device and Output device articles) and use it for playback or recording, for example. MIDI devices API classes are placed in the Melanchall.DryWetMidi.Multimedia namespace. To understand what is an input and an output device in DryWetMIDI take a look at the following image: So, as you can see, although a MIDI port is MIDI IN for MIDI device, it will be an output device in DryWetMIDI because your application will send MIDI data to this port. MIDI OUT of MIDI device will be an input device in DryWetMIDI because a program will receive MIDI data from the port. If some error occured during sending or receiving a MIDI event, the ErrorOccurred event will be fired holding an exception caused the error."
  },
  "articles/devices/Virtual-device.html": {
    "href": "articles/devices/Virtual-device.html",
    "title": "Virtual device | DryWetMIDI",
    "keywords": "Virtual device Important Virtual devices API available for macOS only. For Windows you can use products like virtualMIDI SDK or similar to work with virtual MIDI ports programmatically. Be careful with license of these products. With DryWetMIDI you can programmatically create virtual MIDI devices with the specified name using VirtualDevice.Create method. In fact virtual device is an input and an output devices paired together in a way that any MIDI event sent to the output device will be immediately transfered back from the virtual device and can be received by an application from its input subdevice. Thus we have loopback device here. Loopback device is useful, for example, as intermediate layer between an application and some software synthesizer. In this case: you create virtual device, for example, named as MyDevice ; in the application you set MyDevice as an output MIDI port, so the application will send MIDI data to the output subdevice of the virtual device; in software synthesizer you set MyDevice as an input MIDI port. So when you create virtual device an input device and an output one are created with the same name as the one specified on virtual device creation. Subdevices of a virtual device are available via InputDevice and OutputDevice properties of the VirtualDevice class. Of course you can use those device separately as regular input and output devices: using System; using Melanchall.DryWetMidi.Multimedia; namespace DwmExamples { class Program { static void Main(string[] args) { var virtualDevice = VirtualDevice.Create(\"MyDevice\"); Console.WriteLine($\"Virtual device {virtualDevice} created with subdevices:\"); Console.WriteLine($\" input = {virtualDevice.InputDevice.Name}\"); Console.WriteLine($\" output = {virtualDevice.OutputDevice.Name}\"); var inputDevice = InputDevice.GetByName(\"MyDevice\"); Console.WriteLine($\"Input device {inputDevice.Name} got as regular input device.\"); var outputDevice = OutputDevice.GetByName(\"MyDevice\"); Console.WriteLine($\"Output device {outputDevice.Name} got as regular output device.\"); Console.ReadKey(); } } } Output of the program: Virtual device Virtual device created with subdevices: input = MyDevice output = MyDevice Input device MyDevice got as regular input device. Output device MyDevice got as regular output device. You can even combine virtual devices and DevicesConnector to broadcast MIDI data to several applications (synthesizers, for example) at the same time: using System; using Melanchall.DryWetMidi.Common; using Melanchall.DryWetMidi.Core; using Melanchall.DryWetMidi.Multimedia; namespace DwmExamples { class Program { static void Main(string[] args) { var rootDevice = VirtualDevice.Create(\"Root\"); rootDevice.InputDevice.StartEventsListening(); // Important, don't forget! var leafDevice1 = VirtualDevice.Create(\"Leaf1\"); leafDevice1.InputDevice.EventReceived += OnLeafEventReceived; var leafDevice2 = VirtualDevice.Create(\"Leaf2\"); leafDevice2.InputDevice.EventReceived += OnLeafEventReceived; var devicesConnector = rootDevice.InputDevice.Connect( leafDevice1.OutputDevice, leafDevice2.OutputDevice); leafDevice1.InputDevice.StartEventsListening(); leafDevice2.InputDevice.StartEventsListening(); var midiEvent = new NoteOnEvent((SevenBitNumber)70, (SevenBitNumber)60) { Channel = (FourBitNumber)5 }; Console.WriteLine($\"Sending {midiEvent} event...\"); rootDevice.OutputDevice.SendEvent(midiEvent); Console.ReadKey(); } private static void OnLeafEventReceived(object sender, MidiEventReceivedEventArgs e) { var device = (MidiDevice)sender; Console.WriteLine($\"Event {e.Event} received on device {device.Name}.\"); } } } This program will print following lines: Sending Note On [5] (70, 60) event... Event Note On [5] (70, 60) received on device Leaf1. Event Note On [5] (70, 60) received on device Leaf2. As with input and output device you should always dispose virtual device when you're done with it: virtualDevice.Dispose(); You must not explicitly dispose subdevices of a virtual device. More than that calling Dispose on virtualDevice.InputDevice and virtualDevice.OutputDevice will throw an exception. But if you got references to the subdevices by regular methods (for example, by InputDevice.GetByName ), you can call Dispose on that references of course."
  },
  "articles/file-reading-writing/MIDI-file-reading.html": {
    "href": "articles/file-reading-writing/MIDI-file-reading.html",
    "title": "MIDI file reading | DryWetMIDI",
    "keywords": "MIDI file reading The simplest code for MIDI file reading is: var file = MidiFile.Read(\"Some great song.mid\"); After that you have instance of the MidiFile . Its Chunks property returns collection of chunks within the MIDI file read. Using this collection you can manage chunks (add new, delete existing one and so on). MIDI file reading process can be finely adjusted via ReadingSettings . For example, if we want to abort reading on unknown chunk (about reading custom chunks see Custom chunks article), you can set corresponding policy: var file = MidiFile.Read(\"Some great song.mid\", new ReadingSettings { UnknownChunkIdPolicy = UnknownChunkIdPolicy.Abort }); ReadingSettings has a lot of useful properties. You can read documentation on all of them to learn how you can adjust MIDI file reading. Reading corrupted files DryWetMIDI allows to read MIDI files with various violations of SMF standard. Example below shows how to read a MIDI file with different errors: var file = MidiFile.Read(\"Some great song.mid\", new ReadingSettings { InvalidChannelEventParameterValuePolicy = InvalidChannelEventParameterValuePolicy.ReadValid, InvalidChunkSizePolicy = InvalidChunkSizePolicy.Ignore, InvalidMetaEventParameterValuePolicy = InvalidMetaEventParameterValuePolicy.SnapToLimits, MissedEndOfTrackPolicy = MissedEndOfTrackPolicy.Ignore, NoHeaderChunkPolicy = NoHeaderChunkPolicy.Ignore, NotEnoughBytesPolicy = NotEnoughBytesPolicy.Ignore, UnexpectedTrackChunksCountPolicy = UnexpectedTrackChunksCountPolicy.Ignore, UnknownChannelEventPolicy = UnknownChannelEventPolicy.SkipStatusByteAndOneDataByte, UnknownChunkIdPolicy = UnknownChunkIdPolicy.ReadAsUnknownChunk, UnknownFileFormatPolicy = UnknownFileFormatPolicy.Ignore, }); Please read more about these properties in the API section to learn about what options are available to handle each error. If some policies set to Abort , an instance of corresponding exception will be thrown. All such exceptions types are derived from MidiException and listed in Exceptions section of Read methods ( by file path or by stream ) on API documentation."
  },
  "articles/file-reading-writing/MIDI-file-writing.html": {
    "href": "articles/file-reading-writing/MIDI-file-writing.html",
    "title": "MIDI file writing | DryWetMIDI",
    "keywords": "MIDI file writing The simplest code for MIDI file writing is: file.Write(\"Some great song.mid\"); If file with this name already exist, you'll get an excption. To overwrite existing file pass true to overwriteFile parameter: file.Write(\"Some great song.mid\", overwriteFile: true); Compression You can set specific policies via WritingSettings to reduce size of an output file. For example, to use running status and thus don't write status bytes of channel events of the same type, set properties shown in the following code: file.Write(\"Some great song.mid\", settings: new WritingSettings { UseRunningStatus = true, NoteOffAsSilentNoteOn = true }); Complete list of available properties is placed in documentation of WritingSettings ."
  },
  "articles/high-level-managing/Getting-objects.html": {
    "href": "articles/high-level-managing/Getting-objects.html",
    "title": "Getting objects | DryWetMIDI",
    "keywords": "Getting objects This article describes ways to get different objects (like timed events or notes ) from MIDI files, track chunks and collections of another objects. GetTimedEvents TimedEvent is the basic MIDI object we will describe here. It's just a MIDI event along with its absolute time within a MIDI file or track chunk. To get all timed events in a MIDI file, you can just call GetTimedEvents method: using System; using Melanchall.DryWetMidi.Core; using Melanchall.DryWetMidi.Interaction; namespace DwmExamples { class Program { static void Main(string[] args) { var midiFile = MidiFile.Read(\"My Great Song.mid\"); var timedEvents = midiFile.GetTimedEvents(); Console.WriteLine($\"{timedEvents.Count} timed events found.\"); } } } Please examine TimedEventsManagingUtilities class to see other GetTimedEvents overloads. GetNotes There is the NotesManagingUtilities class which provides useful methods GetNotes to get notes from a MIDI file or track chunk. For example, you can get notes a MIDI file contains with this code: using System; using Melanchall.DryWetMidi.Common; using Melanchall.DryWetMidi.Core; using Melanchall.DryWetMidi.Interaction; namespace DwmExamples { class Program { static void Main(string[] args) { var midiFile = new MidiFile( new TrackChunk( new NoteOnEvent(), new NoteOffEvent(), new NoteOnEvent((SevenBitNumber)70, (SevenBitNumber)50) { Channel = (FourBitNumber)5, DeltaTime = 10 }, new NoteOffEvent((SevenBitNumber)70, (SevenBitNumber)30) { Channel = (FourBitNumber)5, DeltaTime = 70 })); Console.WriteLine(\"Notes:\"); foreach (var note in midiFile.GetNotes()) { Console.Write($@\" note {note} (note number = {note.NoteNumber}) time = {note.Time} length = {note.Length} velocity = {note.Velocity} off velocity = {note.OffVelocity}\"); } Console.ReadKey(); } } } Running the program, we'll see following output: Notes: note C-1 (note number = 0) time = 0 length = 0 velocity = 0 off velocity = 0 note A#4 (note number = 70) time = 10 length = 70 velocity = 50 off velocity = 30 Please examine NotesManagingUtilities class to see other GetNotes overloads. Settings All GetNotes overloads can accept NoteDetectionSettings as last parameter. Via this parameter you can adjust the process of notes building. Let's see each setting in details. NoteStartDetectionPolicy The NoteStartDetectionPolicy property defines how start event of a note should be found in case of overlapping notes with the same note number and channel. The default value is NoteStartDetectionPolicy.FirstNoteOn . To understand how this policy works let's take a look at the following events sequence: where empty circle and filled one mean Note On and Note Off events correspondingly; cross means any other event. So we have two overlapped notes here (we assume all note events have the same note number and channel). If we set NoteStartDetectionPolicy to NoteStartDetectionPolicy.FirstNoteOn , notes will be constructed in following way: So every Note Off event will be combined with first free Note On event into a note (events are processed one by one consecutively). But if set NoteStartDetectionPolicy to NoteStartDetectionPolicy.LastNoteOn , we'll get another picture: So Note Off events will be combined with last free Note On event into a note. NoteSearchContext The NoteSearchContext property defines a context to search notes within. The default value is NoteSearchContext.SingleEventsCollection . The property is applicable only to GetChords that accepts collection of TrackChunk s and MidiFile . To understand how this policy works let's take a look at the following events sequences within two track chunks: where empty circle and filled one mean Note On and Note Off events correspondingly; cross means any other event. So we have two overlapped notes here (we assume all note events have the same note number). So we have two overlapped notes here. We assume that NoteStartDetectionPolicy.FirstNoteOn is used to search a note's start and all note events have the same note number. If we use NoteSearchContext.SingleEventsCollection as the context, notes will be constructed in the following way: So every Note On event will be combined with Note Off one within the same events collection. But if we use NoteSearchContext.AllEventsCollections , notes will be constructed in a new way: So Note On event can be combined now with Note Off one within different events collection, i.e. ends of a note can be placed in difefrent track chunks. GetChords There is the ChordsManagingUtilities class which provides useful methods GetChords to get notes from a MIDI file or track chunk. For example, you can get chords a MIDI file contains with this code: using System; using Melanchall.DryWetMidi.Common; using Melanchall.DryWetMidi.Core; using Melanchall.DryWetMidi.Interaction; namespace DwmExamples { class Program { static void Main(string[] args) { var midiFile = new MidiFile( new TrackChunk( new NoteOnEvent(), new NoteOffEvent(), new NoteOnEvent { Channel = (FourBitNumber)5, DeltaTime = 10 }, new NoteOffEvent { Channel = (FourBitNumber)5 }, new NoteOnEvent((SevenBitNumber)70, (SevenBitNumber)50) { Channel = (FourBitNumber)5 }, new NoteOffEvent((SevenBitNumber)70, (SevenBitNumber)30) { Channel = (FourBitNumber)5, DeltaTime = 70 })); Console.WriteLine(\"Chords:\"); foreach (var chord in midiFile.GetChords()) { Console.Write($@\" chord channel = {chord.Channel} time = {chord.Time} length = {chord.Length} notes:\"); foreach (var note in chord.Notes) { Console.Write($@\" note {note} (note number = {note.NoteNumber}) channel = {note.Channel} time = {note.Time} length = {note.Length} velocity = {note.Velocity} off velocity = {note.OffVelocity}\"); } } Console.ReadKey(); } } } Running the program, we'll see following output: Chords: chord channel = 0 time = 0 length = 0 notes: note C-1 (note number = 0) channel = 0 time = 0 length = 0 velocity = 0 off velocity = 0 chord channel = 5 time = 10 length = 70 notes: note C-1 (note number = 0) channel = 5 time = 10 length = 0 velocity = 0 off velocity = 0 note A#4 (note number = 70) channel = 5 time = 10 length = 70 velocity = 50 off velocity = 30 Please examine ChordsManagingUtilities class to see other GetChords overloads. Settings All GetChords overloads can accept ChordDetectionSettings as last parameter. Via this parameter you can adjust the process of chords building. Let's see each setting in details. NoteDetectionSettings Chords are built on top of notes. So to build chords we need to build notes. The process of notes building is adjustable via NoteDetectionSettings property. Properties of the NoteDetectionSettings are described in detail above . NotesTolerance The NotesTolerance property defines the maximum distance of notes from the start of the first note of a chord. Notes within this tolerance will be included in a chord. The default value is 0 . To understand how this property works let's take a look at the following notes (cross means any non-note event): If we set notes tolerance to 0 (which is default value), we'll get three different chords (each of one note): Different colors denotes different chords. If we set notes tolerance to 1 , we'll get two chords: With tolerance of 2 we'll finally get a single chord: NotesMinCount The NotesMinCount property defines the minimum count of notes a chord can contain. So if count of simultaneously sounding notes is less than this value, they won't make up a chord. The default value is 1 which means a single note can be turned to a chord. To understand how this property works let's take a look at the following notes (cross means any non-note event): So we have three notes. For simplicity we'll assume that NotesTolerance is 0 (default value). If we set notes min count to 1 (which is default value), we'll get two different chords: If we set notes min count to 2 , we'll get only one chord: Last note will not be turned into a chord because count of notes for a chord will be 1 which is less than the specified minimum count. With minimum count of notes of 3 we'll get no chords: First possible chord will contain two notes and second chord will contain one note. In both cases count of notes is less than the specified minimum count. ChordSearchContext The ChordSearchContext property defines a context to search chords within. The default value is ChordSearchContext.SingleEventsCollection . The property is applicable only to GetChords that accepts collection of TrackChunk s and MidiFile . To understand how this policy works let's take a look at the following data within two track chunks: If we use ChordSearchContext.SingleEventsCollection as the context, chords will be constructed in the following way: So chords will be constructed only from notes within the same events collection (track chunk). But if we use ChordSearchContext.AllEventsCollections , chords will be constructed in a new way: So a chord can be constructed from notes within different events collections. GetObjects All methods we saw before return collection of objects of the same type . So you can get only either notes or chords or timed events. To highlight the problem, let's take a look at the following events sequence: where empty circle and filled one mean Note On and Note Off events correspondingly; cross means any other event. We assume all note events have the same note number and channel. With GetTimedEvents we'll just get all these events as is. GetNotes will give us only notes: GetChords will return only chords (single one in this example): So if we run following simple program: using System; using System.Collections.Generic; using Melanchall.DryWetMidi.Core; using Melanchall.DryWetMidi.Interaction; namespace DwmExamples { class Program { static void Main(string[] args) { var midiFile = new MidiFile( new TrackChunk( new TextEvent(\"1\"), new NoteOnEvent { DeltaTime = 1 }, new TextEvent(\"2\") { DeltaTime = 1 }, new NoteOffEvent { DeltaTime = 1 }, new TextEvent(\"3\") { DeltaTime = 1 }, new NoteOnEvent { DeltaTime = 1 }, new TextEvent(\"4\") { DeltaTime = 1 }, new NoteOffEvent { DeltaTime = 1 }, new TextEvent(\"5\") { DeltaTime = 1 }, new NoteOnEvent { DeltaTime = 1 }, new TextEvent(\"6\")), new TrackChunk( new TextEvent(\"A\"), new TextEvent(\"B\") { DeltaTime = 1 }, new TextEvent(\"C\") { DeltaTime = 1 }, new TextEvent(\"D\") { DeltaTime = 1 }, new TextEvent(\"E\") { DeltaTime = 1 }, new NoteOnEvent { DeltaTime = 1 }, new TextEvent(\"F\") { DeltaTime = 1 }, new NoteOffEvent { DeltaTime = 1 }, new TextEvent(\"G\") { DeltaTime = 1 }, new TextEvent(\"H\") { DeltaTime = 1 }, new TextEvent(\"I\"))); Console.WriteLine(\"Getting timed events...\"); WriteTimedObjects(midiFile.GetTimedEvents()); Console.WriteLine(\"Getting notes...\"); WriteTimedObjects(midiFile.GetNotes()); Console.WriteLine(\"Getting chords...\"); WriteTimedObjects(midiFile.GetChords(new ChordDetectionSettings { ChordSearchContext = ChordSearchContext.AllEventsCollections, NotesMinCount = 2 })); Console.ReadKey(); } private static void WriteTimedObjects<TObject>(ICollection<TObject> timedObjects) where TObject : ITimedObject { foreach (var timedObject in timedObjects) { Console.WriteLine($\"[{timedObject.GetType().Name}] {timedObject} (time = {timedObject.Time})\"); } } } } we'll get this output: Getting timed events... [TimedEvent] Event at 0: Text (1) (time = 0) [TimedEvent] Event at 0: Text (A) (time = 0) [TimedEvent] Event at 1: Note On [0] (0, 0) (time = 1) [TimedEvent] Event at 1: Text (B) (time = 1) [TimedEvent] Event at 2: Text (2) (time = 2) [TimedEvent] Event at 2: Text (C) (time = 2) [TimedEvent] Event at 3: Note Off [0] (0, 0) (time = 3) [TimedEvent] Event at 3: Text (D) (time = 3) [TimedEvent] Event at 4: Text (3) (time = 4) [TimedEvent] Event at 4: Text (E) (time = 4) [TimedEvent] Event at 5: Note On [0] (0, 0) (time = 5) [TimedEvent] Event at 5: Note On [0] (0, 0) (time = 5) [TimedEvent] Event at 6: Text (4) (time = 6) [TimedEvent] Event at 6: Text (F) (time = 6) [TimedEvent] Event at 7: Note Off [0] (0, 0) (time = 7) [TimedEvent] Event at 7: Note Off [0] (0, 0) (time = 7) [TimedEvent] Event at 8: Text (5) (time = 8) [TimedEvent] Event at 8: Text (G) (time = 8) [TimedEvent] Event at 9: Note On [0] (0, 0) (time = 9) [TimedEvent] Event at 9: Text (6) (time = 9) [TimedEvent] Event at 9: Text (H) (time = 9) [TimedEvent] Event at 9: Text (I) (time = 9) Getting notes... [Note] C-1 (time = 1) [Note] C-1 (time = 5) [Note] C-1 (time = 5) Getting chords... [Chord] C-1 C-1 (time = 5) As you can see there is \"free\" Note On event without corresponding Note Off one so we can't build a note for it. What if we want to get all possible notes and all remaining timed events? DryWetMIDI provides GetObjectsUtilities class which contains GetObjects methods (for the same MIDI structures as previous methods). We can change printing part of the program above to: Console.WriteLine(\"Getting notes and timed events...\"); WriteTimedObjects(midiFile.GetObjects(ObjectType.Note | ObjectType.TimedEvent)); which will give us following output: Getting notes and timed events... [TimedEvent] Event at 0: Text (1) (time = 0) [TimedEvent] Event at 0: Text (A) (time = 0) [Note] C-1 (time = 1) [TimedEvent] Event at 1: Text (B) (time = 1) [TimedEvent] Event at 2: Text (2) (time = 2) [TimedEvent] Event at 2: Text (C) (time = 2) [TimedEvent] Event at 3: Text (D) (time = 3) [TimedEvent] Event at 4: Text (3) (time = 4) [TimedEvent] Event at 4: Text (E) (time = 4) [Note] C-1 (time = 5) [Note] C-1 (time = 5) [TimedEvent] Event at 6: Text (4) (time = 6) [TimedEvent] Event at 6: Text (F) (time = 6) [TimedEvent] Event at 8: Text (5) (time = 8) [TimedEvent] Event at 8: Text (G) (time = 8) [TimedEvent] Event at 9: Note On [0] (0, 0) (time = 9) [TimedEvent] Event at 9: Text (6) (time = 9) [TimedEvent] Event at 9: Text (H) (time = 9) [TimedEvent] Event at 9: Text (I) (time = 9) So all note events that build up a note were turned into instances of Note , and all remaining events (including \"free\" Note On one) were returned as instances of TimedEvent . We can go futher and collect all possible chords, notes and timed events: Console.WriteLine(\"Getting chords, notes and timed events...\"); WriteTimedObjects(midiFile.GetObjects( ObjectType.Chord | ObjectType.Note | ObjectType.TimedEvent, new ObjectDetectionSettings { ChordDetectionSettings = new ChordDetectionSettings { ChordSearchContext = ChordSearchContext.AllEventsCollections, NotesMinCount = 2 } })); which will give us following output: Getting chords, notes and timed events... [TimedEvent] Event at 0: Text (1) (time = 0) [TimedEvent] Event at 0: Text (A) (time = 0) [Note] C-1 (time = 1) [TimedEvent] Event at 1: Text (B) (time = 1) [TimedEvent] Event at 2: Text (2) (time = 2) [TimedEvent] Event at 2: Text (C) (time = 2) [TimedEvent] Event at 3: Text (D) (time = 3) [TimedEvent] Event at 4: Text (3) (time = 4) [TimedEvent] Event at 4: Text (E) (time = 4) [Chord] C-1 C-1 (time = 5) [TimedEvent] Event at 6: Text (4) (time = 6) [TimedEvent] Event at 6: Text (F) (time = 6) [TimedEvent] Event at 8: Text (5) (time = 8) [TimedEvent] Event at 8: Text (G) (time = 8) [TimedEvent] Event at 9: Note On [0] (0, 0) (time = 9) [TimedEvent] Event at 9: Text (6) (time = 9) [TimedEvent] Event at 9: Text (H) (time = 9) [TimedEvent] Event at 9: Text (I) (time = 9) Or in visual representation: Currently GetObjects can build objects of the following types: TimedEvent Note Chord Rest Rests Let's see on rests building in details, since GetObjects is the only way to get them. First of all, all GetObjects overloads accept settings as an instance of the ObjectDetectionSettings class. Most of its properties are already discussed in previous sections on notes building settings and chords building ones . But there is the RestDetectionSettings property which controls how rests should be detected. Supposing we have following notes (with two different note numbers on two different channels): RestDetectionSettings provides RestSeparationPolicy property which determines a rule for creating rests. Now we'll see how each possible value of the policy affects the result of rests building. Using NoSeparation (which is the default value) we'll get only one rest: \"No separation\" means \"there is no difference between channels and note numbers\" so rests will be constructed only at spaces where there are no notes at all (with any channels and any note numbers). With SeparateByChannel we'll get three rests: So rests are separated by channels only. Note number of a note doesn't matter, all numbers are treated as the same one. So rests will be constructed for each channel at spaces where there are no notes (with any note numbers). With SeparateByNoteNumber we'll get following rests: As you can see rests now are separated by note number (channel doesn't matter). So rests will be constructed for each note number at spaces where there are no notes (with any channel). With SeparateByChannelAndNoteNumber we'll get rests at every \"free\" space: Let's see all these processes in action with a small program: using System; using System.Collections.Generic; using System.Linq; using Melanchall.DryWetMidi.Common; using Melanchall.DryWetMidi.Interaction; using NoteName = Melanchall.DryWetMidi.MusicTheory.NoteName; namespace DwmExamples { class Program { static void Main(string[] args) { var ch0 = (FourBitNumber)0; var a2Ch0Notes = new[] { new Note(NoteName.A, 2, 3, 0) { Channel = ch0 }, new Note(NoteName.A, 2, 2, 6) { Channel = ch0 }, new Note(NoteName.A, 2, 2, 8) { Channel = ch0 }, new Note(NoteName.A, 2, 3, 11) { Channel = ch0 } }; var b1Ch0Notes = new[] { new Note(NoteName.B, 1, 3, 1) { Channel = ch0 }, new Note(NoteName.B, 1, 4, 4) { Channel = ch0 }, new Note(NoteName.B, 1, 1, 13) { Channel = ch0 } }; var ch1 = (FourBitNumber)1; var a2Ch1Notes = new[] { new Note(NoteName.A, 2, 2, 0) { Channel = ch1 }, new Note(NoteName.A, 2, 2, 7) { Channel = ch1 } }; var b1Ch1Notes = new[] { new Note(NoteName.B, 1, 3, 1) { Channel = ch1 }, new Note(NoteName.B, 1, 3, 5) { Channel = ch1 }, new Note(NoteName.B, 1, 2, 12) { Channel = ch1 } }; var notes = a2Ch0Notes .Concat(b1Ch0Notes) .Concat(a2Ch1Notes) .Concat(b1Ch1Notes) .ToArray(); WriteRests(notes, RestSeparationPolicy.NoSeparation); WriteRests(notes, RestSeparationPolicy.SeparateByChannel); WriteRests(notes, RestSeparationPolicy.SeparateByNoteNumber); WriteRests(notes, RestSeparationPolicy.SeparateByChannelAndNoteNumber); Console.ReadKey(); } private static void WriteRests( ICollection<Note> notes, RestSeparationPolicy restSeparationPolicy) { var rests = notes .GetObjects( ObjectType.Rest, new ObjectDetectionSettings { RestDetectionSettings = new RestDetectionSettings { RestSeparationPolicy = restSeparationPolicy } }) .Cast<Rest>() .ToArray(); Console.WriteLine($\"Rests by {restSeparationPolicy} policy:\"); foreach (var rest in rests) { Console.WriteLine($\"[{rest.Length}] at [{rest.Time}] (note number = {rest.NoteNumber}, channel = {rest.Channel})\"); } } } } Output is: Rests by NoSeparation policy: [1] at [10] (note number = , channel = ) Rests by SeparateByChannel policy: [1] at [4] (note number = , channel = 1) [3] at [9] (note number = , channel = 1) [1] at [10] (note number = , channel = 0) Rests by SeparateByNoteNumber policy: [1] at [0] (note number = 35, channel = ) [3] at [3] (note number = 45, channel = ) [4] at [8] (note number = 35, channel = ) [1] at [10] (note number = 45, channel = ) Rests by SeparateByChannelAndNoteNumber policy: [1] at [0] (note number = 35, channel = 0) [1] at [0] (note number = 35, channel = 1) [5] at [2] (note number = 45, channel = 1) [3] at [3] (note number = 45, channel = 0) [1] at [4] (note number = 35, channel = 1) [4] at [8] (note number = 35, channel = 1) [5] at [8] (note number = 35, channel = 0) [1] at [10] (note number = 45, channel = 0)"
  },
  "articles/high-level-managing/Objects-managers.html": {
    "href": "articles/high-level-managing/Objects-managers.html",
    "title": "Objects managers | DryWetMIDI",
    "keywords": "Objects managers Working with low-level objects (like MIDI event) sometimes is not convenient. In this cases it's much more handy to manage MIDI data via concepts of timed events , notes or chords . DryWetMIDI provides a way to work with such high-level objects - TimedObjectsManager . This class allows to work with objects of different types within an events collection (see TrackChunk.Events ): using (var manager = new TimedObjectsManager(trackChunk.Events, ObjectType.Note | ObjectType.TimedEvent)) { foreach (var obj in manager.Objects) { if (obj is Note note) note.Length -= 10; else if (obj is TimedEvent timedEvent && timedEvent.Event is BaseTextEvent textEvent) textEvent.Text = \"Hello\"; } manager.Objects.RemoveAll(obj => obj is Note note && note.Channel == 9); manager.Objects.Add(new TimedEvent(new ProgramChangeEvent((SevenBitNumber)7), 100)); } All changes made with a manager will not be saved until SaveChanges or Dispose method will be called. So the recommended practice to work with managers is using (var notesManager = trackChunk.ManageNotes()) { // ... } or if managing is happen in different parts of a program var notesManager = new TimedObjectsManager<Note>(trackChunk.Events); // ... notesManager.SaveChanges(); Objects will be placed in the underlying events collection in chronological order of course. Also as you can see there is the generic constructor that allows to manage objects of the single type. Objects property will return in this case objects of this type, no need to cast them to the type. Simultaneous editing of events collection On saving the manager will rewrite all content of the underlying events collection. So you shouldn't modify the collection while working with the manager since all unsaved changes will be lost on manager's SaveChanges or Dispose . For example, this code using (var timedEventsManager = new TimedObjectsManager<TimedEvent>(trackChunk.Events)) using (var notesManager = new TimedObjectsManager<Note>(trackChunk.Events)) { // All changes made with the notesManager will be lost } or var timedEventsManager = new TimedObjectsManager<TimedEvent>(trackChunk.Events); var notesManager = new TimedObjectsManager<Note>(trackChunk.Events); // All changes made with the notesManager will be lost timedEventsManager.SaveChanges(); will cause changes made with the notesManager will be lost because SaveChanges (or Dispose in first code snippet) of timedEventsManager executed after SaveChanges of notesManager , and thus rewrites underlying events collection. You need to save changes made with a previous manager before managing objects with next one."
  },
  "articles/high-level-managing/Tempo-map.html": {
    "href": "articles/high-level-managing/Tempo-map.html",
    "title": "Tempo map | DryWetMIDI",
    "keywords": "Tempo map Tempo map is a set of changes of time signature and tempo. Tempo map is one of the key objects in high-level managing of MIDI data. You need to have a tempo map to convert time and length between different representations, either explicitly or internally at some parts of the library (for example, in tools ). Following image shows how tempo map constructed for a given set of events or MIDI file: So as you can see tempo map doesn't reflect original MIDI events. Tempo map holds real tempo and time signature changes. Default tempo is 120 BPM by MIDI specifications so there is no need to hold first two tempo \"changes\" because tempo is not changed in fact. The same for time signature (which is 4/4 by default). Also any repeated values are ignored since they don't change tempo or time signature. Instead of messing with Time Signature and Set Tempo events DryWetMIDI provides TempoMapManager which helps to manage tempo map of a MIDI file: using (var tempoMapManager = new TempoMapManager( midiFile.TimeDivision, midiFile.GetTrackChunks().Select(c => c.Events))) { TempoMap tempoMap = tempoMapManager.TempoMap; Tempo tempoAt123 = tempoMap.GetTempoAtTime((MidiTimeSpan)123); // Change tempo to 400000 microseconds per quarter note at 20 seconds from // MIDI file start tempoMapManager.SetTempo(new MetricTimeSpan(0, 0, 20), new Tempo(400000)); tempoMapManager.ClearTimeSignature(456); } To get tempo map being managed by the current TempoMapManager you need to use TempoMap property which returns an instance of the TempoMap class. Once you've got an instance of TempoMap you can use GetTempoChanges method to get all tempo changes. Use GetTimeSignatureChanges method to get time signature changes. GetTempoAtTime and GetTimeSignatureAtTime methods allow to get tempo and time signature at the specified time. You can also create new tempo map with TempoMapManager : using (var tempoMapManager = new TempoMapManager()) { // ... } If you want to create a simple tempo map with some fixed tempo or/and time signature without changes, use Create static methods of the TempoMap class. There is another way to get an instance of the TempoMapManager � through the ManageTempoMap extension method: using (var tempoMapManager = midiFile.ManageTempoMap()) { // ... } This method and another useful ones are placed in TempoMapManagingUtilities . For example, to get tempo map of a MIDI file you can write: TempoMap tempoMap = midiFile.GetTempoMap(); Also you can replace the entire tempo map of a MIDI file using ReplaceTempoMap method: midiFile.ReplaceTempoMap(TempoMap.Create(Tempo.FromBeatsPerMinute(140)));"
  },
  "articles/high-level-managing/Time-and-length.html": {
    "href": "articles/high-level-managing/Time-and-length.html",
    "title": "Time and length | DryWetMIDI",
    "keywords": "Time and length All times and lengths in a MIDI file are presented as some long values in units defined by the time division of a MIDI file. In practice it is much more convenient to operate by \"human understandable\" representations like seconds or bars/beats. In fact there is no difference between time and length since time within a MIDI file is just a length that always starts at zero, so the time span term will be used to describe both time and length. DryWetMIDI provides the following classes to represent time span: MetricTimeSpan for time span in terms of microseconds; BarBeatTicksTimeSpan for time span in terms of number of bars, beats and ticks; BarBeatFractionTimeSpan for time span in terms of number of bars and fractional beats (for example, 0.5 beats); MusicalTimeSpan for time span in terms of a fraction of the whole note length; MidiTimeSpan exists for unification purposes and simply holds long value in units defined by the time division of a file. All time span classes implement ITimeSpan interface. To convert time span between different representations you should use TimeConverter or LengthConverter classes (these conversions require tempo map of a MIDI file). (You can use LengthConverter for time conversions too but with the TimeConverter you don't need to specify time where time span starts since it is always zero.) Examples of time conversions: var tempoMap = midiFile.GetTempoMap(); // Some time in MIDI ticks (we assume time division of a MIDI file is \"ticks per quarter note\") long ticks = 123; // Convert ticks to metric time MetricTimeSpan metricTime = TimeConverter.ConvertTo<MetricTimeSpan>(ticks, tempoMap); // Convert ticks to musical time MusicalTimeSpan musicalTimeFromTicks = TimeConverter.ConvertTo<MusicalTimeSpan>(ticks, tempoMap); // Convert metric time to musical time MusicalTimeSpan musicalTimeFromMetric = TimeConverter.ConvertTo<MusicalTimeSpan>(metricTime, tempoMap); // Convert metric time to bar/beat time BarBeatTicksTimeSpan barBeatTicksTimeFromMetric = TimeConverter.ConvertTo<BarBeatTicksTimeSpan>(metricTime, tempoMap); // Convert musical time back to ticks long ticksFromMusical = TimeConverter.ConvertFrom(musicalTimeFromTicks, tempoMap); Examples of length conversions: var tempoMap = midiFile.GetTempoMap(); // Convert ticks to metric length MetricTimeSpan metricLength = LengthConverter.ConvertTo<MetricTimeSpan>(ticks, time, tempoMap); // Convert metric length to musical length using metric time MusicalTimeSpan musicalLengthFromMetric = LengthConverter.ConvertTo<MusicalTimeSpan>(metricLength, metricTime, tempoMap); // Convert musical length back to ticks long ticksFromMetricLength = LengthConverter.ConvertFrom(metricLength, time, tempoMap); You could notice that LengthConverter 's methods take a time as parameter. In general case MIDI file has changes of the tempo and time signature. Thus the same long (X) value can represent different amount of seconds, for example, depending on the time of an object with length of this X value. The methods above can take time either as long or as ITimeSpan . There are some useful methods in the TimedObjectUtilities class. This class contains extension methods for types that implement the ITimedObject interface – TimedEvent , Note and Chord . For example, you can get time of a timed event in hours, minutes, seconds with TimeAs method: var metricTime = timedEvent.TimeAs<MetricTimeSpan>(tempoMap); Or you can find all notes of a MIDI file that start at time of 10 bars and 4 beats: TempoMap tempoMap = midiFile.GetTempoMap(); IEnumerable<Note> notes = midiFile .GetNotes().AtTime(new BarBeatTicksTimeSpan(10, 4), tempoMap); Also there is the LengthedObjectUtilities class. This class contains extension methods for types that implement the ILengthedObject interface – Note and Chord . For example, you can get length of a note as a fraction of the whole note with LengthAs method: var musicalLength = note.LengthAs<MusicalTimeSpan>(tempoMap); Or you can get all notes of a MIDI file that end exactly at 30 seconds from the start of the file: var tempoMap = midiFile.GetTempoMap(); var notesAt30sec = midiFile .GetNotes().EndAtTime(new MetricTimeSpan(0, 0, 30), tempoMap); TimeAs (end EndTimeAs ) and LengthAs methods have non-generic versions where the desired type of result should be passed as an argument of the TimeSpanType type. ITimeSpan interface has several methods to perform arithmetic operations on time spans. For example, to add metric length to metric time you can write: var timeSpan1 = new MetricTimeSpan(0, 2, 20); var timeSpan2 = new MetricTimeSpan(0, 0, 10); ITimeSpan result = timeSpan1.Add(timeSpan2, TimeSpanMode.TimeLength); You need to specify mode of the operation. In the example above TimeLength is used which means that first time span represents a time and the second one represents a length. This information is needed for conversion engine when operands are of different types. There are also TimeTime and LengthLength modes. You can also subtract one time span from another one: var timeSpan1 = new MetricTimeSpan(0, 10, 0); var timeSpan2 = new MusicalTimeSpan(3, 8); ITimeSpan result = timeSpan1.Subtract(timeSpan2, TimeSpanMode.TimeTime); If operands of the same type, result time span will be of this type too. But if you sum or subtract time spans of different types, the type of a result time span will be MathTimeSpan which holds operands along with operation (addition or subtraction) and mode. To stretch or shrink a time span use Multiply or Divide methods: ITimeSpan stretchedTimeSpan = new MetricTimeSpan(0, 0, 10).Multiply(2.5); ITimeSpan shrinkedTimeSpan = new BarBeatTicksTimeSpan(0, 2).Divide(2); There are some useful methods in the TimeSpanUtilities class. These methods include Parse and TryParse ones that allows to parse a string to appropriate time span. Please read article corresponding to desired time span type to learn formats of strings that can be parsed to this type (use links at the start of this article). Representations DryWetMIDI provides several representations of time spans. Metric MetricTimeSpan represents time span as a number of microseconds. Following strings can be parsed to MetricTimeSpan : Hours : Minutes : Seconds : Milliseconds HoursGroup : Minutes : Seconds Minutes : Seconds Hours h Minutes m Seconds s Milliseconds ms Hours h Minutes m Seconds s Hours h Minutes m Milliseconds ms Hours h Seconds s Milliseconds ms Minutes m Seconds s Milliseconds ms Hours h Minutes m Hours h Seconds s Hours h Milliseconds ms Minutes m Seconds s Hours h Milliseconds ms Seconds s Milliseconds ms Hours h Minutes m Seconds s Milliseconds ms where Hours is a number of hours. Minutes is a number of minutes. Seconds is a number of seconds. Milliseconds is a number of milliseconds. Examples: 0:0:0:0 – zero time span 0:0:0:156 – 156 milliseconds 2:0:156 – 2 hours and 156 seconds 1:156 – 1 minute and 156 seconds 1h2m3s4ms – 1 hour 2 minutes 3 seconds 4 milliseconds 1h 2m3s – 1 hour 2 minutes 3 seconds 1h2M 4ms – 1 hour 2 minutes 4 milliseconds 1 h3s4ms – 1 hour 3 seconds 4 milliseconds 2M3 S 4 MS – 2 minutes 3 seconds 4 milliseconds 1h2m – 1 hour 2 minutes 1h 3s – 1 hour 3 seconds 1h4MS – 1 hour 4 milliseconds 2M3s – 2 minutes 3 seconds 2 m 4 Ms – 2 minutes 4 milliseconds 3 s 4 mS – 2 seconds 4 milliseconds Bars, beats and ticks BarBeatTicksTimeSpan represents a time span as a number of bars, beats and MIDI ticks. Following strings can be parsed to BarBeatTicksTimeSpan : Bars.Beats.Ticks where Bars is a number of bars. Beats is a number of beats. Ticks is a number of MIDI ticks. Examples: 0.0.0 – zero time span 1.0.0 – 1 bar 0.10.5 – 10 beats and 5 ticks 100.20.0 – 100 bars and 20 ticks Bars, beats and fraction BarBeatFractionTimeSpan represents a time span as a number of bars and fractional beats (for example, 0.5 beats). Following strings can be parsed to BarBeatFractionTimeSpan : Bars_BeatsIntegerPart.BeatsFractionalPart where Bars is a number of bars. BeatsIntegerPart is an integer part of fractional beats number. BeatsFractionalPart is a fractional part of fractional beats number. Examples: 0_0.0 – zero time span 1_0.0 – 1 bar 0_10.5 – 10.5 beats 100_20.2 – 100 bars and 20.2 beats Musical MusicalTimeSpan represents a time span as a fraction of the whole note, for example, 1/4 (quarter note length). Following strings can be parsed to MusicalTimeSpan : Fraction Tuplet Dots where Fraction defines note length which is one of the following terms: Numerator/Denominator where Numerator and Denominator are nonnegative integer numbers; Numerator can be omitted assuming it's 1 ; w , h , q , e or s which mean whole, half, quarter, eighth or sixteenth note length respectively. Tuplet represents tuplet definition which is one of the following terms: [NotesCount : SpaceSize] where NotesCount is positive integer count of notes with length defined by Fraction part; SpaceSize is the count of notes of normal length. t or d which mean triplet and duplet respectively. Dots is any number of dots. Tuplet and Dots parts can be omitted. Examples: 0/1 – zero time span q – quarter note length 1/4. – dotted quarter note length /8.. – double dotted eighth note length wt. – dotted whole triplet note length w[3:10] – length of 3 whole notes in space of 10 notes of normal length s[3:10]... – length of 3 sixteenth triple dotted notes in space of 10 notes of normal length MIDI MidiTimeSpan exists for unification purposes and simply holds long value in units defined by the time division of a MIDI file. Following strings can be parsed to MidiTimeSpan : Value where Value is a number of MIDI ticks. Examples: 0 – zero time span 100 – 100 ticks 123456 – 123456 ticks"
  },
  "articles/music-theory/Chord.html": {
    "href": "articles/music-theory/Chord.html",
    "title": "Chord | DryWetMIDI",
    "keywords": "Chord Chord represents a musical chord as a collection of notes names. Some examples of usage: // Create chord by root note name and intervals from root var chordByIntervals = new Chord(NoteName.A, Interval.FromHalfSteps(2), Interval.FromHalfSteps(5)); // Create A B chord var chordByNotesNames = new Chord(NoteName.A, NoteName.B); // Create C Major chord var cMajorTriad = Chord.GetByTriad(NoteName.C, ChordQuality.Major); // ... or parse it from string var cMajorTriadFromString = Chord.Parse(\"C\"); // Parse more complex chord from string var cAug7Chord = Chord.Parse(\"Caug7\"); Last chord will contain C, E, G# and A# notes as expected. Chords parsing uses Chord Names Table (CNT) so not all possible chords can be parsed since CNT contains limited set of chords naming rules. If you notice that some known chord name is not parsed by DryWetMIDI, please create an issue on GitHub and CNT will be extended. See following section for details. Parsing Following strings can be parsed to Chord : RootNote ChordCharacteristic RootNote ChordCharacteristic BassNote where RootNote is the root note of a chord, for example, A or C# . ChordCharacteristic is combination of chord quality, altered and added tones and so on. See Chords names table section below to learn what characteristics are supported by the library. BassNote is an added bass note the chord will be placed over. Examples of valid chord strings: C Caug7 Cm Am Cm7 CmM7 Csus2 C9sus4 F/G C7b5 Chords names table Following table shows what chords currently supported for parsing from string and for retrieving names by chords notes. First column lists names and second one shows intervals from root. For example, 0 1 5 for C give us following chord: C C# E . Please note that some interval sets start from number greater than zero. Currently the library doesn't support chords with omitted root, but the feature will be implemented in the future. Names Intervals maj M 0 4 7 min m 0 3 7 sus4 0 5 7 sus2 0 2 7 b5 0 4 6 dim 0 3 6 aug 0 4 8 min6 m6 0 3 7 9 maj6 M6 6 0 4 7 9 7 0 4 7 10 7sus4 0 5 7 10 7sus2 0 2 7 10 min7 m7 0 3 7 10 min9 min7(9) m9 m7(9) 0 3 7 10 14 0 3 10 14 3 10 14 (not supported) 3 7 10 14 (not supported) min11 min7(9,11) m11 m7(9,11) 0 3 7 10 14 17 0 3 10 14 17 3 10 14 17 (not supported) 3 7 10 14 17 (not supported) maj7 0 4 7 11 maj7(9) M7(9) 0 4 7 11 14 0 4 11 14 4 11 14 (not supported) 4 7 11 14 (not supported) maj7(#11) M7(#11) 0 4 7 11 14 18 0 4 11 14 18 4 11 14 18 (not supported) 4 7 11 14 18 (not supported) maj7(13) M7(13) 0 4 7 11 21 0 4 11 21 4 11 21 (not supported) 4 7 11 21 (not supported) maj7(9,13) M7(9,13) 0 4 7 11 14 21 0 4 11 14 21 4 11 14 21 (not supported) 4 7 11 14 21 (not supported) maj7#5 M7#5 0 4 8 11 maj7#5(9) M7#5(9) 0 4 8 11 14 4 8 11 14 (not supported) minMaj7 mM7 0 3 7 11 minMaj7(9) mM7(9) 0 3 7 11 14 0 3 11 14 3 11 14 (not supported) 3 7 11 14 (not supported) 5 0 7 7b5 dom7dim5 7dim5 0 4 6 10 ø ø7 m7b5 min7dim5 m7dim5 min7b5 m7b5 0 3 6 10 aug7 7#5 7+5 0 4 8 10 dim7 0 3 6 9 add9 0 4 7 14 minAdd9 mAdd9 0 3 7 14 maj6(9) 6(9) 6/9 M6/9 M6(9) 0 4 7 9 14 4 7 9 14 (not supported) 0 4 9 14 4 9 14 (not supported) min6(9) m6(9) m6/9 min6/9 0 3 7 9 14 3 7 9 14 (not supported) 0 3 9 14 3 9 14 (not supported) 9 0 4 7 10 14 9sus2 0 2 7 10 14 9sus4 0 5 7 10 14 11 0 4 7 10 14 17 7b9 0 4 7 10 13 add11 0 4 7 17 7#11 7+11 7(#11) 7aug11 0 4 7 10 18"
  },
  "articles/music-theory/Chord-progression.html": {
    "href": "articles/music-theory/Chord-progression.html",
    "title": "Chord progression | DryWetMIDI",
    "keywords": "Chord progression ChordProgression represents set of chords which represents musical chord progression. Some examples of usage: // Get I-II-IV chord progression for C Major scale var chordProgression = ChordProgression.Parse(\"I-II-IV\", Scale.Parse(\"C major\")); // Get chords of chord progression var chords = chordProgression.Chords; Parsing Following strings can be parsed to ChordProgression : DegreeNumber ChordCharacteristic - DegreeNumber ChordCharacteristic - ... - DegreeNumber ChordCharacteristic where DegreeNumber is a scale degree as a roman number, for example, I or IV . ChordCharacteristic is combination of chord quality, altered and added tones and so on. See Parsing section of Chord article to learn more. Examples of valid chord progression strings: I-II-IV Im-II7-V"
  },
  "articles/music-theory/Interval.html": {
    "href": "articles/music-theory/Interval.html",
    "title": "Interval | DryWetMIDI",
    "keywords": "Interval Interval holds number of half steps and used, for example, to transpose notes or describing chords when working with PatternBuilder . Some examples of usage: // Get A4 note var a4 = Octave.Get(4).A; // Transpose the note up by two half steps var twoHalfTonesUp = Interval.FromHalfSteps(2); var b4 = a4 + twoHalfTonesUp; // Transpose the note down by two octaves var twoOctavesDown = Interval.FromHalfSteps(-24); var a2 = a4.Transpose(twoOctavesDown); // Transpose the note up by three half steps var c5 = a4 + Interval.Three; // Invert interval var twoOctavesUp = -twoOctavesDown; Parsing Following strings can be parsed to Interval : HalfSteps IntervalQuality IntervalNumber where HalfSteps is a number of half-steps, for example, +4 or -10 . IntervalQuality is one of the following letters: P for perfect interval; d for diminished interval; A for augmented interval; m for minor interval; M for major interval. IntervalNumber is a number of interval, for example, 1 . A number must be greater than zero. Examples of valid interval strings: +8 0 7 -123 P5 m3 M3 D21 d8 A7 a18"
  },
  "articles/music-theory/Note.html": {
    "href": "articles/music-theory/Note.html",
    "title": "Note | DryWetMIDI",
    "keywords": "Note Note class holds a note's name and octave number. To get an instance of Note , call appropriate Get (for example, Get(noteName, octave) ) static method or parse a note from string. You can also get specific note using corresponding property of Octave class. Some examples of usage: // Get note with number of 100 var note1 = Note.Get((SevenBitNumber)100); // Get A#2 note var note2 = Note.Get(NoteName.ASharp, 2); // ... or var note3 = Octave.Get(2).ASharp; // Parse a note var note4 = Note.Parse(\"a3\"); var note5Parsed = Note.TryParse(\"c#2\", out var note5); Also see Interval article for additional examples. Parsing Following strings can be parsed to Note : NoteName Accidental Accidental ... Accidental OctaveNumber where NoteName is one of the letters: C , D , E , F , G , A or B . Accidental is one of the following strings: # or sharp for sharp; b or flat for flat. OctaveNumber is a number of octave. A number must be between -1 and 9 . Examples of valid note strings: D3 F##3 Fb 1 C#b4"
  },
  "articles/music-theory/Octave.html": {
    "href": "articles/music-theory/Octave.html",
    "title": "Octave | DryWetMIDI",
    "keywords": "Octave The main purpose of the Octave class is to provide alternative way to get an instance of the Note class. Some examples of usage: // Get first octave var firstOctave = Octave.Get(1); // Then we can get notes from this octave in a simple way var aSharpNote = firstOctave.ASharp; var bNote = firstOctave.B; // Get middle C note var middleC = Octave.Middle.C; Parsing Following strings can be parsed to Octave : OctaveNumber where OctaveNumber is a number of octave. A number must be between -1 and 9 . Examples of valid interval strings: -1 8 0"
  },
  "articles/music-theory/Overview.html": {
    "href": "articles/music-theory/Overview.html",
    "title": "Music Theory - Overview | DryWetMIDI",
    "keywords": "Music Theory - Overview DryWetMIDI provides types and methods to work with music theory objects like scale or chord progression, and provides ways to use them within MIDI. Following list shows what objects you can work with: Octave ; Interval ; Note ; Chord ; Chord progression ; Scale . Note that DryWetMIDI uses Scientific Pitch Notation so middle C note is C4 one. Octave.Middle returns that 4th octave. You can read interesting discussion about different notations here: MIDI Octave and Note Numbering Standard . All corresponding classes have Parse and TryParse method so you can get an instance of a class from string. For example, you can parse \"C#\" string to C# note."
  },
  "articles/music-theory/Scale.html": {
    "href": "articles/music-theory/Scale.html",
    "title": "Scale | DryWetMIDI",
    "keywords": "Scale DryWetMIDI provides Scale class to work with musical scales. Some examples of usage: // Create C Major scale var cMajorScale = new Scale(ScaleIntervals.Major, NoteName.C); // Get a note that belongs to C Major scale next to the C2. var d2 = cMajorScale.GetNextNote(Octave.Get(2).C); // Get a note that belongs to C Major scale previous to the F2. var e2 = cMajorScale.GetPreviousNote(Octave.Get(2).F); // Get note by scale degree var c = cMajorScale.GetDegree(ScaleDegree.Tonic); // Get ten ascending notes that belong to C Major scale starting from D2 var tenAscendingNotes = cMajorScale.GetAscendingNotes(Octave.Get(2).D).Take(10); // Get five descending notes that belong to C Major scale starting from F4 var fiveDescendingNotes = cMajorScale.GetDescendingNotes(Octave.Get(4).F).Take(5); // Parse a scale var dMinor = Scale.Parse(\"D minor\"); // Create custom scale by the specified intervals between adjacent notes and root note var customScale1 = new Scale(new[] { Interval.One, Interval.Seven, Interval.Two }, NoteName.CSharp); // Parse custom scale var customScaleParsed = Scale.TryParse(\"C# +1 +7 +2\", out var customScale2); Last example shows parsing of custom scale defined by tonic (C#) and intervals between adjacent degrees (+1, +7 and +2). So notes of the scale are C#, D, A and B. Parsing Following strings can be parsed to Scale : RootNote ScaleName RootNote Interval Interval ... Interval where RootNote is a note name (with or without accidental), for example, C or A# . ScaleName is the name of a known scale, for example, major or bebop minor . You can take a look at ScaleIntervals to see all known scales supported by the library. Interval is a string a musical interval can be parsed from. See Parsing section of the Interval article to see how an interval can be represented as a string. Examples of valid scale strings: C major D blues A# P5 d7 Bb +3 +1 +4"
  },
  "articles/playback/Common-problems.html": {
    "href": "articles/playback/Common-problems.html",
    "title": "Common problems | DryWetMIDI",
    "keywords": "Common problems Playback doesn't produce sound or events logs Make sure an instance of Playback class is holded by class field, global variable or something else that can live longer that method where you instantiate Playback . In this case private void StartPlayback() { var playback = _midiFile.GetPlayback(); playback.Start(); } playback variable will \"die\" (will be ready to be collected by GC) after program exits StartPlayback method so playback won't work. Unity hangs or crash on entering Play mode second time By default Playback uses HighPrecisionTickGenerator tick generator (see Tick generator article to learn more). HighPrecisionTickGenerator uses WinAPI methods by P/Invoke wich causes troubles in Unity environment. You may notice that Unity hangs forever if you hit Play button second time. Unfortunately it seems the problem won't be fixed. Answer of Unity tech support: Unfortunately, that is correct = we will not be able to fix this in the near term because it probably requires rewriting of internal threading functionality, which might introduce new issues. The main case has been tagged for a revisit internally, but it will probably be months until the case is re-valuated again. Solution is to use either RegularPrecisionTickGenerator or a custom one. Related issues on GitHub: Playback produces unexpected results in Unity Visualization of notes SetActive can only be called from the main thread in Unity Sometimes you want to handle playback events or use event or note callbacks. Your code can be executed on separate thread in these cases. It can happen because of Playback 's internals (like tick generator 's tick handling) work on separate thread. But UI related things like call of SetActive can be executed on UI thread only. You can use the solution from here: https://stackoverflow.com/a/56715254 . Related issues on GitHub: trigger object with a note in Unity"
  },
  "articles/playback/Current-time-watching.html": {
    "href": "articles/playback/Current-time-watching.html",
    "title": "Current time watching | DryWetMIDI",
    "keywords": "Current time watching To watch current time of a playback you can create a timer and call GetCurrentTime method on each timer's tick. To simplify this task (especially if you're running multiple playbacks simultaneously) DryWetMIDI provides PlaybackCurrentTimeWatcher class. This class is singleton in order to prevent too many high resolution tick generators are created (which is not good since it can affect whole system performance). Please read Tick generator article to learn how you can ajust internals of the PlaybackCurrentTimeWatcher . Small example: PlaybackCurrentTimeWatcher.Instance.AddPlayback(playback, TimeSpanType.Midi); PlaybackCurrentTimeWatcher.Instance.CurrentTimeChanged += OnCurrentTimeChanged; PlaybackCurrentTimeWatcher.Instance.Start(); // ... private static void OnCurrentTimeChanged(object sender, PlaybackCurrentTimeChangedEventArgs e) { foreach (var playbackTime in e.Times) { var playback = playbackTime.Playback; var time = (MidiTimeSpan)playbackTime.Time; Console.WriteLine($\"Current time is {time}.\"); } } In this example we watch current time of playback and request to report time in MIDI format which is ticks (and thus we cast received time to MidiTimeSpan ). You can set any desired time format and cast to corresponding implementation of the ITimeSpan . You can add multiple different playbacks to watch their current times. When you don't want to watch playback anymore remove it from the watcher: PlaybackCurrentTimeWatcher.Instance.RemovePlayback(playback); By default polling interval of watcher is 100 ms, but you can alter it: PlaybackCurrentTimeWatcher.Instance.PollingInterval = TimeSpan.FromMilliseconds(50); Please don't set too small intervals. Polling interval defines how often CurrentTimeChanged event will be fired. If you want to pause firing the event, call Stop method. When your application is about to close, dispose watcher to kill the internal timer: PlaybackCurrentTimeWatcher.Instance.Dispose();"
  },
  "articles/playback/Custom-playback.html": {
    "href": "articles/playback/Custom-playback.html",
    "title": "Custom playback | DryWetMIDI",
    "keywords": "Custom playback You can subclass from Playback to make your own playback by overriding some protected virtual methods: bool TryPlayEvent(MidiEvent midiEvent, object metadata) IEnumerable GetTimedEvents(ITimedObject timedObject) Let's see what each method needed for. TryPlayEvent TryPlayEvent method called by playback each time an event should be played. Result value of the method tells playback whether the event was played or not. Default implementation of the method just sends a MIDI event to output device and returns true . So you can implement your own logic of playing a MIDI event. Please pay attention to the second parameter of the method - metadata . If input objects of playback implement IMetadata interface, metadata will be passed via that parameter. For example, you can subclass from TimedEvent and implement IMetadata on a new class, and then create your own playback on instances of that class. Sample code below shows how to play a MIDI file filtering out events within first track chunk: private sealed class TimedEventWithTrackChunkIndex : TimedEvent, IMetadata { public TimedEventWithTrackChunkIndex(MidiEvent midiEvent, long time, int trackChunkIndex) : base(midiEvent, time) { Metadata = trackChunkIndex; } public object Metadata { get; set; } } private sealed class MyPlayback : Playback { public MyPlayback(IEnumerable<ITimedObject> timedObjects, TempoMap tempoMap) : base(timedObjects, tempoMap) { } protected override bool TryPlayEvent(MidiEvent midiEvent, object metadata) { if (metadata == 0) return false; OutputDevice?.SendEvent(midiEvent); return true; } } Then create MyPlayback : var timedEvents = midiFile .GetTrackChunks() .SelectMany((c, i) => c.GetTimedEvents().Select(e => new TimedEventWithTrackChunkIndex(e.Event, e.Time, i))) .OrderBy(e => e.Time); var tempoMap = midiFile.GetTempoMap(); var playback = new MyPlayback(timedEvents, tempoMap); GetTimedEvents Playback internally transforms all input objects to instances of TimedEvent . So if some input objects implement ITimedObject but their type is unknown for DryWetMIDI, we need to override GetTimedEvents method to provide transformation of our custom timed object to collection of timed events. Of course those timed events can be subclasses of TimedEvent and implement IMetadata (see previous section) so metadata will correctly go between a playback's internals. By default the method returns empty collection."
  },
  "articles/playback/Data-tracking.html": {
    "href": "articles/playback/Data-tracking.html",
    "title": "Playback data tracking | DryWetMIDI",
    "keywords": "Playback data tracking Playback provides a way to track some MIDI data to correctly handle jumps in time and get properly sounding data. There are two main groups of data to track: notes MIDI parameters (pitch bend, program, control value) Notes tracking Let's take a look at the following events sequence to play: Playback class has TrackNotes property. If its value is true , playback will internally construct notes based on input objects to play. So in our example one note will be constructed: Now let's imagine a playback's time is at some point and we want to jump to a new one (with MoveToTime for example): If we now jump to a new time that falls in the middle of the note, behavior of the playback will be different depending on TrackNotes property value. In case of the property value is false nothing special will happen, just the current time of the playback will be changed. But if we set TrackNotes to true , new Note On event will be generated and played when we jump to the new time: The same situation with opposite case: So we want here to jump from the middle of a note to the time after the note. As in previous example if TrackNotes is false , just the current time of the playback will be changed. But if in case of true , new Note Off event will be generated and played when we jump to the new time. So TrackNotes = true tells playback to track time jumps when the current time pointer of the playback either leaves a note or enters one to finish or start the note correspondingly. Of course in cases like this: playback will play both Note Off event (since we're leaving the first note) and Note On one (since we're entering the second note). MIDI parameters values tracking Let's imagine we have the following events sequence to play: And now we want to jump from the current time of a playback to a new time (with MoveToTime for example): So by the current time A event is played and the current program corresponds to A . If the playback just change the current time, the note will be played using program A which may be wrong since the note is actually is under B program influence. To track a program Playback class has TrackProgram property. If it's set to false , nothing will happen except changing the current time. All following notes can sound incorrectly due to possibly skipped program changes. But if we set TrackProgram to true , playback will play required Program Change event immediately after time changed. So in our example B will be played and then playback continues from new time: Program tracking works in opposite direction too of course: We have program B active at the current time. But when we jump to a new time (before B but after A ), A event will be played. Playback can track at now three MIDI parameters: program ; pitch bend ; control value . We have discussed program tracking above. But tracking the remaining two parameters is absolutely the same. To track pitch bend value there is TrackPitchValue property. To track control value there is TrackControlValue property. Of course all these parameters are tracked separately for each MIDI channel and in addition to this control value tracked separately for each control number."
  },
  "articles/playback/Overview.html": {
    "href": "articles/playback/Overview.html",
    "title": "Playback - Overview | DryWetMIDI",
    "keywords": "Playback - Overview Playback class allows to play MIDI events via an IOutputDevice (see Output device article) or without a device at all (see Playback without device ). To get an instance of the Playback you can use its constructors or GetPlayback extension methods in PlaybackUtilities . Following example shows simple console app where specified MIDI file is played until end of the file reached or B note is about to be played. So in our example B note means to stop playback. using System; using System.Linq; using System.Threading; using Melanchall.DryWetMidi.Core; using Melanchall.DryWetMidi.Multimedia; namespace SimplePlaybackApp { class Program { private static Playback _playback; static void Main(string[] args) { var midiFile = MidiFile.Read(\"The Greatest Song Ever.mid\"); var outputDevice = OutputDevice.GetByName(\"Microsoft GS Wavetable Synth\"); _playback = midiFile.GetPlayback(outputDevice); _playback.NotesPlaybackStarted += OnNotesPlaybackStarted; _playback.Start(); SpinWait.SpinUntil(() => !_playback.IsRunning); Console.WriteLine(\"Playback stopped or finished.\"); outputDevice.Dispose(); _playback.Dispose(); } private static void OnNotesPlaybackStarted(object sender, NotesEventArgs e) { if (e.Notes.Any(n => n.NoteName == Melanchall.DryWetMidi.MusicTheory.NoteName.B)) _playback.Stop(); } } } Please read Tick generator article and PlaybackSettings class documentation to learn how you can adjust playback's internals. Playback without device There are constructors of Playback that don't accept IOutputDevice as an argument. It can be useful, for example, for notes visualization without sound. Playback provides events that will be fired with or without output device (see Events section of the Playback API page). Also all GetPlayback extensions methods have overloads without the outputDevice parameter. Also if you don't specify output device and use tick generator other than HighPrecisionTickGenerator , you can use Playback in cross-platform app like Unity game that is supposed to be built for different platforms. Blocking playback If you call Play method of the Playback , the calling thread will be blocked until entire collection of MIDI events will be played. Note that execution of this method will be infinite if the Loop property set to true . There are also extension methods Play in PlaybackUtilities : using (var outputDevice = OutputDevice.GetByName(\"Output MIDI device\")) { MidiFile.Read(\"Some MIDI file.mid\").Play(outputDevice); // ... } Non-blocking playback Is you call Start method of the Playback , execution of the calling thread will continue immediately after the method is called. To stop playback use Stop method. Note that there is no any pausing method since it's useless. Stop leaves playback at the point where the method was called. To move to the start of the playback use MoveToStart method. Important You should be very careful with this approach and using block. Example below shows the case where part of MIDI data will not be played because of playback is disposed before the last MIDI event will be played: using (var outputDevice = OutputDevice.GetByName(\"Output MIDI device\")) using (var playback = MidiFile.Read(\"Some MIDI file.mid\").GetPlayback(outputDevice)) { playback.Start(); // ... } With non-blocking approach you must call Dispose manually after you've finished work with playback object."
  },
  "articles/playback/Tick-generator.html": {
    "href": "articles/playback/Tick-generator.html",
    "title": "Tick generator | DryWetMIDI",
    "keywords": "Tick generator Playback uses timer under the hood. In DryWetMIDI this timer called tick generator. On every tick of timer playback looks what objects should be played by the current time, plays them and advances position within objects list waiting for next tick. To make playback smooth and correct, precision of timer should be ~1ms. So tick will be generated every one millisecond. By default, DryWetMIDI uses HighPrecisionTickGenerator which is the best option in terms of CPU usage, memory usage and precision. Important HighPrecisionTickGenerator is supported for Windows and macOS only at now. You can also use RegularPrecisionTickGenerator which uses standard Timer and thus provides precision about 16ms on Windows. But this tick generator is cross-platform. Tick generator can be specified via playbackSettings parameter of Playback 's constructors or GetPlayback extension methods within PlaybackUtilities : var playback = midiFile.GetPlayback(new PlaybackSettings { ClockSettings = new MidiClockSettings { CreateTickGeneratorCallback = () => new RegularPrecisionTickGenerator() } }); Custom tick generator All built-in tick generators extend abstract TickGenerator class so you can create your own and use it for Playback and PlaybackCurrentTimeWatcher . As an example we create simple loop tick generator working in separate thread. The code is: private sealed class ThreadTickGenerator : TickGenerator { private Thread _thread; private bool _isRunning; private bool _disposed; protected override void Start(TimeSpan interval) { if (_thread != null) return; _thread = new Thread(() => { var stopwatch = new Stopwatch(); var lastMs = 0L; stopwatch.Start(); _isRunning = true; while (_isRunning) { var elapsedMs = stopwatch.ElapsedMilliseconds; if (elapsedMs - lastMs >= interval.TotalMilliseconds) { GenerateTick(); lastMs = elapsedMs; } } }); _thread.Start(); } protected override void Dispose(bool disposing) { if (_disposed) return; if (disposing) { _isRunning = false; } _disposed = true; } } And then use it: var playback = midiFile.GetPlayback(new PlaybackSettings { ClockSettings = new MidiClockSettings { CreateTickGeneratorCallback = () => new ThreadTickGenerator() } }); Of course this tick generator will use a lot of CPU due to infinite loop but it's for demo purposes only. Manual ticking Also you can tick playback's internal clock manually without tick generator via TickClock method of Playback . For example, you can use manual ticking within every frame update in Unity. To use only manual ticking you should return null in CreateTickGeneratorCallback : var playback = midiFile.GetPlayback(new PlaybackSettings { ClockSettings = new MidiClockSettings { CreateTickGeneratorCallback = () => null } }); and then call playback.TickClock(); when needed. You also can use manual ticking in conjunction with tick generator."
  },
  "articles/recording/Overview.html": {
    "href": "articles/recording/Overview.html",
    "title": "Recording - Overview | DryWetMIDI",
    "keywords": "Recording - Overview To capture MIDI data from an input MIDI device (see Input device article) you can use Recording class which will collect incoming MIDI events. To start recording you need create an instance of the Recording class passing tempo map and input device to its constructor: using Melanchall.DryWetMidi.Multimedia; using Melanchall.DryWetMidi.Interaction; // ... using (var inputDevice = InputDevice.GetByName(\"Input MIDI device\")) { var recording = new Recording(TempoMap.Default, inputDevice); // ... } Don't forget to call StartEventsListening on IInputDevice before you start recording since Recording do nothing with the device you've specified. To start recording call Start method. To stop it call Stop method. You can resume recording after it has been stopped by calling Start again. To check whether recording is currently running or not, get a value of the IsRunning property. Start and Stop methods fire Started and Stopped events respectively. You can get recorded events as with GetEvents method. Take a look at small example of MIDI data recording: using (var inputDevice = InputDevice.GetByName(\"Input MIDI device\")) { var recording = new Recording(TempoMap.Default, inputDevice); inputDevice.StartEventsListening(); recording.Start(); // ... recording.Stop(); var recordedFile = recording.ToFile(); recording.Dispose(); recordedFile.Write(\"Recorded data.mid\"); }"
  },
  "articles/tools/Merger.html": {
    "href": "articles/tools/Merger.html",
    "title": "Merger | DryWetMIDI",
    "keywords": "Merger To merge nearby objects into one DryWetMIDI provides Merger class. Quick example of merging in action: Process of merging can be adjusted via ObjectsMergingSettings . By default two objects should have no gap between them to be merged. But you can specify any desired tolerance via settings: var newObjects = objects.MergeObjects( TempoMap.Default, new ObjectsMergingSettings { Tolerance = new MetricTimeSpan(0, 0, 1) }); Now objects will be merged if the distance between them from 0 to 1 second. So tolerance is maximum distance between two objects to consider them as nearby. Please take a look at how tolerance ( T ) affects process of merging: Of course merging available not for objects collections only. You can use also MergeObjects methods on MidiFile and TrackChunk : midiFile.MergeObjects( ObjectType.Note | ObjectType.Chord, new ObjectsMergingSettings { Filter = obj => obj.Time > 100 }, new ObjectDetectionSettings { ChordDetectionSettings = new ChordDetectionSettings { NotesMinCount = 3 } }); The tool need to determine somehow whether two objects have the same \"key\" or not to take decision about merging them. For example, if we have a C note and D one, by default such notes are different in terms of their keys and thus won't be merged. To understand what the key is, please read MIDI file splitting: SplitByObjects article. Of course you can customize how objects are merged. For example, following picture shows how chords are merged using the default merging logic: Now let's change the logic: chords can be merged only if there are notes in them without gap. Also notes in result chord need to start at the same time and have the same length. Following image shows how chords will be merged: We need to derive from the ObjectsMerger class to implement these rules: private sealed class ChordsMerger : ObjectsMerger { public ChordsMerger(ILengthedObject obj) : base(obj) { } public override bool CanAddObject(ILengthedObject obj, TempoMap tempoMap, ObjectsMergingSettings settings) { if (!base.CanAddObject(obj, tempoMap, settings)) return false; var chordNotes = ((Chord)obj).Notes.ToArray(); var lastChordNotes = ((Chord)_objects.Last()).Notes.ToArray(); return Enumerable .Range(0, lastChordNotes.Length) .Any(i => lastChordNotes[i].EndTime == chordNotes[i].Time); } public override ILengthedObject MergeObjects(ObjectsMergingSettings settings) { var result = (Chord)base.MergeObjects(settings); var time = result.Time; var length = result.Length; foreach (var note in result.Notes) { note.Time = time; note.Length = length; } return result; } } And now we can merge objects using this class: midiFile.MergeObjects( ObjectType.Chord | ObjectType.Note, new ObjectsMergingSettings { ObjectsMergerFactory = obj => obj is Chord ? new ChordsMerger(obj) : new ObjectsMerger(obj) }, new ObjectDetectionSettings { ChordDetectionSettings = new ChordDetectionSettings { NotesTolerance = 100 } }); So if the tool encounters a chord, it uses our custom merger; for any other object's type - default one."
  },
  "articles/tools/MIDI-file-splitting.html": {
    "href": "articles/tools/MIDI-file-splitting.html",
    "title": "MIDI file splitting | DryWetMIDI",
    "keywords": "MIDI file splitting You can split a MIDI file in different ways using extension methods from the Splitter class. Available methods are described below. Please note that the article doesn't cover all possible methods and their settings. Please read API documentation on Splitter to get complete information. SplitByChannel SplitByChannel method splits a MIDI file by channel so all channel events will be separated by channel and copied to corresponding new files. All meta and system exclusive events will be copied to all the new files (that's default behavior that can be turned off). Thus each new file will contain all meta and sysex events and channel ones for a single channel. The image below illustrates this process: SplitByObjects SplitByObjects method splits a MIDI file by objects. The process can be adjusted via SplitByObjectsSettings passed to the second parameter of the method. For example, to split a file by notes copying all MIDI events to each new file: var newFiles = midiFile.SplitByObjects( ObjectType.Note | ObjectType.TimedEvent, new SplitByObjectsSettings { WriteToAllFilesPredicate = obj => obj is TimedEvent }); Here we specify that we need to split the file by notes and timed events, but every timed event must be written to all result files. So in fact we're splitting the file by notes having all non-notes timed events presented in each new file. The image below illustrates the process: To split a file by objects the tool needs to determine the key of each object. Objects with the same key will be outputted in a separate file. In the example above default logic of key calculation is used. The following table shows what a default key is for each type of an object: Object type Key TimedEvent The type of the underlying event ( EventType of TimedEvent.Event ). Note Pair of the channel and note number of a note. Chord Collection of keys of the underlying notes . Rest Pair of the channel and note number of a rest. You can alter key calculation logic providing custom key selector. For example, to separate notes by only note number ignoring a note's channel: var newFiles = midiFile.SplitByObjects( ObjectType.Note | ObjectType.TimedEvent, new SplitByObjectsSettings { KeySelector = obj => obj is Note note ? ObjectIdUtilities.GetObjectId(note.NoteNumber) : obj.GetObjectId(), WriteToAllFilesPredicate = obj => obj is TimedEvent }); ObjectIdUtilities.GetObjectId(value) returns an implementation of IObjectId which simply holds the provided value. ObjectIdUtilities.GetObjectId(object) returns the default ID (key) for an object. So if an object is a note, we use its note number as the key; and default key for any other object types. If custom logic of key selection is complex, you may decide to implement the IObjectId interface and return that implementation. Just for example, let's create an ID class that identifies a chord by its shortest name: private sealed class ChordNameId : IObjectId { private readonly string _name; public ChordNameId(Chord chord) { _name = chord.GetMusicTheoryChord().GetNames().FirstOrDefault(); } public override bool Equals(object obj) => obj is ChordNameId chordNameId && chordNameId._name == _name; public override int GetHashCode() => _name.GetHashCode(); } And now we can use it to split a file by chords of the same name: var newFiles = midiFile.SplitByObjects( ObjectType.Chord, new SplitByObjectsSettings { KeySelector = obj => new ChordNameId((Chord)obj) }); Please see documentation on SplitByObjectsSettings to learn more about how you can adjust the process of splitting. SplitByGrid SplitByGrid method splits MIDI file by the specified grid. Each file will preserve original tempo map and all parameters changes (like a control value or program changes). The image below shows general case of splitting a MIDI file by grid: Splitting can be adjusted via settings parameter of the SliceMidiFileSettings type. SplitNotes and PreserveTimes properties described below. Please see all available properties in documentation for SliceMidiFileSettings . SplitNotes SplitNotes indicates whether notes should be split at points of grid intersection or not. The default value is true . If false used, notes treated as just Note On / Note Off events rather than note objects. Splitting notes produces new Note On / Note Off events at points where grid intersects notes if the property set to true . The following image shows splitting by grid if SplitNotes set to false : PreserveTimes PreserveTimes indicates whether original times of events should be preserved or not. The default value is false . If false used, events will be moved to the start of a new file. If true used, events will be placed in new files at the same times as in the input file. The following image shows splitting in case of PreserveTimes set to true : SkipPart SkipPart method skips part of the specified length of a MIDI file and returns remaining part as an instance of MidiFile . The image below shows general case of skipping a part of a MIDI file: TakePart TakePart methods take part of the specified length of a MIDI file (starting at the start or at the specified time within the file) and return it as an instance of MidiFile . The image below shows both cases of taking a part of a MIDI file: CutPart CutPart method cuts a part of the specified length from a MIDI file (starting at the specified time within the file) and returns a new instance of MidiFile which is the original file without the part. The image below shows how the method works:"
  },
  "articles/tools/Objects-splitting.html": {
    "href": "articles/tools/Objects-splitting.html",
    "title": "Objects splitting | DryWetMIDI",
    "keywords": "Objects splitting With DryWetMIDI you can use methods of the Splitter class to split objects: SplitObjectsByStep SplitObjectsByPartsNumber SplitObjectsByGrid SplitObjectsAtDistance Each method takes collection of timed objects or MIDI containers (like file or track chunk ) and splits objects within by the specified strategy. These methods are discussed in details below. Also please note that every class that implements ILengthedObject has Split method allowing to split an object at the specified time. SplitObjectsByStep SplitObjectsByStep methods split each object by the specified step starting at the start of an object. For example, if step is 1 second, an object will be split at 1 second from its start, at 1 second from previous point of splitting ( 2 seconds from the object's start), at 1 second from previous point of splitting ( 3 seconds from the object's start) and so on. If an object's length is less than the specified step, the object will not be split and copy of it will be returned. The image below illustrates splitting notes and chord by the same step: SplitObjectsByPartsNumber SplitObjectsByPartsNumber methods split each object into the specified number of parts of equal length. It is necessary to specify the lengthType argument to meet your expectations. For example, with metric type each part of an input object will last the same number of microseconds, while with musical type each part's length will represent the same fraction of the whole note's length. But the length of parts can be different in terms of MIDI ticks using different length type depending on tempo map passed to the method. The image below illustrates splitting notes and chord into 4 parts: SplitObjectsByGrid SplitObjectsByGrid methods split each object by the specified grid. Objects will be split at points of crossing the grid. The image below illustrates splitting notes and chord by the same grid: SplitObjectsAtDistance SplitObjectsAtDistance methods split each object at the specified distance or by the specified ratio from start or end of an object (which is defined by from parameter). It is necessary to specify the lengthType argument for splitting by ratio to meet your expectations. The image below illustrates splitting notes and chord at the same distance from the start of an object: Next image illustrates splitting notes and chord by the ration of 0.25 from the end of an object:"
  },
  "articles/tools/Overview.html": {
    "href": "articles/tools/Overview.html",
    "title": "Overview | DryWetMIDI",
    "keywords": "Overview DryWetMIDI provides some useful tools to solve complex tasks: Splitter to split objects and MIDI files in many different ways. Quantizer to quantize objects. Merger to merge nearby objects. Resizer to resize groups of objects or MIDI files. Repeater to repeat groups of objects or MIDI files. CSV converter to convert MIDI objects to CSV representation and read them back."
  },
  "articles/tools/Quantizer.html": {
    "href": "articles/tools/Quantizer.html",
    "title": "Quantizer | DryWetMIDI",
    "keywords": "Quantizer DryWetMIDI provides a tool to perform quantizing of objects of different types by the specified grid. The class aimed to solve this task is Quantizer . Sections below describe usage of the tool in details. Note that quantizing routine modifies passed objects instead of returning new ones with quantized times. So be sure you've cloned input objects if you want to save them. All classes implementing ITimedObject as well as MidiFile and TrackChunk have Clone method you can use for that purpose. Also there are QuantizerUtilities class that contains useful methods to quantize objects inside TrackChunk and MidiFile without necessity to work with objects collections directly. Please note that the article doesn't cover all settings and use cases so please read API documentation on Quantizer to get complete information. General information First of all let's see how arbitrary timed objects quantized: Quantizing can be adjusted in many ways by the QuantizingSettings . Please read documentation on the class to see all available properties. For example, image below shows quantizing with different values of QuantizingLevel : Quantizing ILengthedObject An arbitrary object implements ITimedObject and thus its Time property gets quantized. But if an object implements ILengthedObject interface, you have several options: quantize start time; quantize end time; quantize both start and end times. You choose the desired option specifying QuantizingSettings.Target property. By default if an object quantized, it will be entirely moved to a grid position. So if you quantize start time, end time can be changed since the object will be moved. You can see the process in action on the first image of the article. Of course this behavior can be altered. Just set FixOppositeEnd to true to prevent changing of time that is not the target of quantizing. The following image illustrates quantizing of start time with the property set to true : Of course this property works in case of end time quantizing too. When the start time of an object is not fixed, there is a chance that the object's end time will be quantized in a such way that the start time will be negative due to the object is moved to the left. Negative time is invalid so you can set QuantizingSettings.QuantizingBeyondZeroPolicy property to desired value to handle this situation. The image below shows how quantizing works if the property set to FixAtZero : Also if one side (start or end) of an object is fixed, there is a chance that the object's opposite time will be quantized in a such way that the object will be reversed resulting to negative length. You can handle this situation with QuantizingSettings.QuantizingBeyondFixedEndPolicy property. The image below shows some options in action when start time is being quantized beyond the end one: Custom quantizing You can derive from the Quantizer class and override its OnObjectQuantizing method. Inside this method you can decide whether quantizing for an object should be performed or not and if yes, what new time should be set. Information about what quantizer is going to do with an object is passed via quantizedTime parameter of QuantizedTime type. Image below shows what information is holded within this class: A : GridTime Grid time that was selected for an object as the nearest one. B : NewTime The new time of an object that was calculated during quantizing. C : DistanceToGridTime The distance between an object's current time and the nearest grid time. There is also ConvertedDistanceToGridTime which holds the distance as time span of the type specified by DistanceCalculationType property of quantizing settings. D : Shift The distance an object is going to be moved on toward the new time. If QuantizingLevel is less than 1.0 , D will be less than C . Let's create a simple custom quantizer. We will call it SoftQuantizer : public sealed class SoftQuantizer : Quantizer { protected override TimeProcessingInstruction OnObjectQuantizing( ITimedObject obj, QuantizedTime quantizedTime, IGrid grid, LengthedObjectTarget target, TempoMap tempoMap, QuantizingSettings settings) { return (MusicalTimeSpan)quantizedTime.ConvertedDistanceToGridTime > MusicalTimeSpan.Eighth ? TimeProcessingInstruction.Skip : base.OnObjectQuantizing(obj, quantizedTime, grid, target, tempoMap, settings); } } What it does? If distance between an object and the nearest grid time is greater than 1/8 , just don't quantize the object. Otherwise do base quantizing. Our small program to test the tool: class Program { static void Main(string[] args) { var tempoMap = TempoMap.Default; var midiFile = new PatternBuilder() .SetNoteLength(MusicalTimeSpan.Eighth) .StepForward(MusicalTimeSpan.Sixteenth) .Note(\"A5\") .StepForward(MusicalTimeSpan.Quarter) .Note(\"B2\") .StepForward(new MusicalTimeSpan(3, 8)) .Note(\"C#3\") .Build() .ToFile(tempoMap); Console.WriteLine(\"Notes before quantizing:\"); PrintNotes(midiFile); midiFile.QuantizeObjects( new SoftQuantizer(), ObjectType.Note, new SteppedGrid(MusicalTimeSpan.Whole), new QuantizingSettings { DistanceCalculationType = TimeSpanType.Musical }); Console.WriteLine(\"Notes after quantizing:\"); PrintNotes(midiFile); Console.WriteLine(\"Press any key to exit...\"); Console.ReadKey(); } static void PrintNotes(MidiFile midiFile) { var notes = midiFile.GetNotes(); var tempoMap = midiFile.GetTempoMap(); foreach (var note in notes) { var time = note.TimeAs<MusicalTimeSpan>(tempoMap); var length = note.LengthAs<MusicalTimeSpan>(tempoMap); Console.WriteLine($\"Note [{note}]: time = [{time}], length = [{length}]\"); } } } If we run the program, we'll get following output: Notes before quantizing: Note [A5]: time = [1/16], length = [1/8] Note [B2]: time = [7/16], length = [1/8] Note [C#3]: time = [15/16], length = [1/8] Notes after quantizing: Note [A5]: time = [0/1], length = [1/8] Note [B2]: time = [7/16], length = [1/8] Note [C#3]: time = [1/1], length = [1/8] Press any key to exit... So all works as expected, middle note is not quantized since it's too far from grid times."
  },
  "articles/tools/Repeater.html": {
    "href": "articles/tools/Repeater.html",
    "title": "Repeater | DryWetMIDI",
    "keywords": "Repeater With DryWetMIDI you can easily repeat groups of objects or entire MIDI files using the dedicated tool - Repeater . Quick example of repeating a group of different objects two times: It's a simple case. To calculate the distance to move each new part by, the tool looks at the value of the ShiftPolicy property of the settings passed to Repeat methods. The default value is ShiftPolicy.ShiftByMaxTime and you can see how this options works on the image above - the tool takes maximum time among all objects and shifts objects within each new part by this value. But you can use fixed value to shift objects by. You need to specify ShiftPolicy.ShiftByFixedValue for shift policy and set Shift property of the settings. So times of objects won't affect distance calculation now and data will be shifted by the value of the Shift property: var newFile = midiFile.Repeat(2, new RepeatingSettings { ShiftPolicy = ShiftPolicy.ShiftByFixedValue, Shift = new MetricTimeSpan(0, 0, 10) }); Also RepeatingSettings class provides options to round shift value (calculated by max time or constant one). It can be useful, for example, when objects are not aligned with the grid. Please take a look at the following image: Here the data doesn't reach bar line time, but we want to repeat the objects with aligning to bars lines. Obviously we can't use ShiftPolicy.ShiftByMaxTime option here. But we can't use ShiftPolicy.ShiftByFixedValue too because we don't know the length of data in general case. We just want to repeat the objects and be sure the start of the objects group is always on a bar line. So we can write this code: var newFile = midiFile.Repeat(2, new RepeatingSettings { ShiftPolicy = ShiftPolicy.ShiftByMaxTime, ShiftRoundingPolicy = TimeSpanRoundingPolicy.RoundUp, ShiftRoundingStep = new BarBeatTicksTimeSpan(1) }); We tell the tool here to round calculated shift value up using the step of 1 bar. By default ShiftRoundingPolicy property is set to TimeSpanRoundingPolicy.NoRounding but you can also set it TimeSpanRoundingPolicy.RoundDown along with TimeSpanRoundingPolicy.RoundUp shown above. Please see documentation on TimeSpanRoundingPolicy to learn more about rounding. Custom repeater You can derive from the Repeater class to make your own repeating logic. Let's imagine we want to repeat all notes transposing each repeated note by three semitones up and shifting it by 1/4 forward. So we need to skip non-note events and disable automatic shifting. The following image illustrates what we want to achieve: Well, our custom repeater class will be: private sealed class CustomRepeater : Repeater { protected override void ProcessPart(PartProcessingContext context) { base.ProcessPart(context); var newObjects = context .PartObjects .Where(obj => ((TimedEvent)obj).Event is NoteEvent) .ToArray(); context.PartObjects.Clear(); foreach (var obj in newObjects) { ((NoteEvent)((TimedEvent)obj).Event).NoteNumber += (SevenBitNumber)((context.PartIndex + 1) * 3); var originalTime = obj.TimeAs<MusicalTimeSpan>(context.SourceTempoMap); obj.SetTime( originalTime.Add(MusicalTimeSpan.Quarter * (context.PartIndex + 1), TimeSpanMode.TimeLength), context.SourceTempoMap); context.PartObjects.Add(obj); } } } And we will use it in this way: var newFile = new CustomRepeater().Repeat(midiFile, 3, new RepeatingSettings { ShiftPolicy = ShiftPolicy.None });"
  },
  "articles/tools/Resizer.html": {
    "href": "articles/tools/Resizer.html",
    "title": "Resizer | DryWetMIDI",
    "keywords": "Resizer DryWetMIDI provides the tool to resize a group of objects or an entire MIDI file - Resizer . Quick example of resizing in action: So as you can see the tool treats all passed objects as a single group and then sizes this group to the new length saving all time-to-length ratios. For example, if an event was at the middle of objects group, it will be at the middle of the group too after resizing. Following image explains this visually for the group of three notes: You use ResizeObjectsGroup methods to stretch or shrink a group of timed objects . You can size a group either to the specified new length or by ratio. Ratio means that all distances from the start of a group will be multiplied by this value. So if ratio of 2 is specified, an objects group will be enlarged by 2 times. And 0.5 means the group will be shrinked by 2 times (new length will be half ( 0.5 ) of the original one). There also Resize methods to resize MidiFile or TrackChunk . If you're resizing a group or file to the specified length, please take care of the distance calculation type which can be set via ObjectsGroupResizingSettings.DistanceCalculationType property of the settings that you can pass to the tool's methods. For example, if you specify new length as a metric one - 10 seconds - it worth to set DistanceCalculationType to the TimeSpanType.Metric value."
  },
  "articles/tools/Splitter.html": {
    "href": "articles/tools/Splitter.html",
    "title": "Splitter | DryWetMIDI",
    "keywords": "Splitter You can split MIDI objects in different ways using extension methods from the Splitter class. In following subsections we'll look at some available methods: objects splitting ; MIDI file splitting . Please note that these articles doesn't cover all possible methods and their settings. Please read API documentation on Splitter to get complete information."
  },
  "index.html": {
    "href": "index.html",
    "title": "Overview | DryWetMIDI",
    "keywords": "Overview DryWetMIDI is the .NET library to work with MIDI data and MIDI devices. It allows: Read, write and create Standard MIDI Files (SMF) . It is also possible to read RMID files where SMF wrapped to RIFF chunk. You can easily catch specific error when reading or writing MIDI file since all possible errors in a MIDI file are presented as separate exception classes. Send MIDI events to/ receive them from MIDI devices, play MIDI data and record it. This APIs support Windows and macOS. Finely adjust process of reading and writing. It allows, for example, to read corrupted files and repair them, or build MIDI file validators. Implement custom meta events and custom chunks that can be written to and read from MIDI files. Manage content of a MIDI file either with low-level objects, like event, or high-level ones, like note (read the High-level data managing section of the library docs ). Build musical compositions (see Pattern page of the library docs) and use music theory API (see Music Theory - Overview article). Perform complex tasks like quantizing, notes splitting or converting MIDI file to CSV representation (see Tools page of the library docs). Please see Getting started section below for quick jump into the library. Useful links NuGet Documentation Project health CodeProject articles: DryWetMIDI: High-Level Processing of MIDI Files DryWetMIDI: Notes Quantization DryWetMIDI: Working with MIDI Devices Projects using DryWetMIDI Here the list of noticeable projects that use DryWetMIDI: Clone Hero Free rhythm game, which can be played with any 5 or 6 button guitar controller, game controllers, or just your standard computer keyboard. The game is a clone of Guitar Hero. Electrophonics A collection of virtual musical instruments that features real MIDI output. Rustissimo Using Rustissimo you can create a concert with your friends and play instruments with synchronization. Sample applications from CIRCE-EYES : https://github.com/melanchall/drywetmidi/issues/105 https://github.com/melanchall/drywetmidi/issues/139 Getting Started Let's see some examples of what you can do with DryWetMIDI. To read a MIDI file you have to use Read static method of the MidiFile : var midiFile = MidiFile.Read(\"Some Great Song.mid\"); or, in more advanced form (visit Reading settings page on the library docs to learn more about how to adjust process of reading) var midiFile = MidiFile.Read( \"Some Great Song.mid\", new ReadingSettings { NoHeaderChunkPolicy = NoHeaderChunkPolicy.Abort, CustomChunkTypes = new ChunkTypesCollection { { typeof(MyCustomChunk), \"Cstm\" } } }); To write MIDI data to a file you have to use Write method of the MidiFile : midiFile.Write(\"My Great Song.mid\"); or, in more advanced form (visit Writing settings page on the library docs to learn more about how to adjust process of writing) midiFile.Write( \"My Great Song.mid\", true, MidiFileFormat.SingleTrack, new WritingSettings { UseRunningStatus = true, NoteOffAsSilentNoteOn = true }); Of course you can create a MIDI file from scratch by creating an instance of the MidiFile and writing it: var midiFile = new MidiFile( new TrackChunk( new SetTempoEvent(500000)), new TrackChunk( new TextEvent(\"It's just single note track...\"), new NoteOnEvent((SevenBitNumber)60, (SevenBitNumber)45), new NoteOffEvent((SevenBitNumber)60, (SevenBitNumber)0) { DeltaTime = 400 })); midiFile.Write(\"My Future Great Song.mid\"); or var midiFile = new MidiFile(); TempoMap tempoMap = midiFile.GetTempoMap(); var trackChunk = new TrackChunk(); using (var notesManager = trackChunk.ManageNotes()) { NotesCollection notes = notesManager.Notes; notes.Add(new Note( NoteName.A, 4, LengthConverter.ConvertFrom( new MetricTimeSpan(hours: 0, minutes: 0, seconds: 10), 0, tempoMap))); } midiFile.Chunks.Add(trackChunk); midiFile.Write(\"My Future Great Song.mid\"); If you want to speed up playing back a MIDI file by two times you can do it with this code: foreach (var trackChunk in midiFile.Chunks.OfType<TrackChunk>()) { foreach (var setTempoEvent in trackChunk.Events.OfType<SetTempoEvent>()) { setTempoEvent.MicrosecondsPerQuarterNote /= 2; } } Of course this code is simplified. In practice a MIDI file may not contain SetTempo event which means it has the default one (500,000 microseconds per beat). Instead of modifying a MIDI file you can use Playback class: using (var outputDevice = OutputDevice.GetByName(\"Microsoft GS Wavetable Synth\")) using (var playback = midiFile.GetPlayback(outputDevice)) { playback.Speed = 2.0; playback.Play(); } To get duration of a MIDI file as TimeSpan use this code: TempoMap tempoMap = midiFile.GetTempoMap(); TimeSpan midiFileDuration = midiFile .GetTimedEvents() .LastOrDefault(e => e.Event is NoteOffEvent) ?.TimeAs<MetricTimeSpan>(tempoMap) ?? new MetricTimeSpan(); or simply: TimeSpan midiFileDuration = midiFile.GetDuration<MetricTimeSpan>(); Suppose you want to remove all C# notes from a MIDI file. It can be done with this code: foreach (var trackChunk in midiFile.GetTrackChunks()) { using (var notesManager = trackChunk.ManageNotes()) { notesManager.Notes.RemoveAll(n => n.NoteName == NoteName.CSharp); } } or midiFile.RemoveNotes(n => n.NoteName == NoteName.CSharp); To get all chords of a MIDI file at 20 seconds from the start of the file write this: TempoMap tempoMap = midiFile.GetTempoMap(); IEnumerable<Chord> chordsAt20seconds = midiFile .GetChords() .AtTime( new MetricTimeSpan(0, 0, 20), tempoMap, LengthedObjectPart.Entire); To create a MIDI file with single note which length will be equal to length of two triplet eighth notes you can use this code: var midiFile = new MidiFile(); var tempoMap = midiFile.GetTempoMap(); var trackChunk = new TrackChunk(); using (var notesManager = trackChunk.ManageNotes()) { var length = LengthConverter.ConvertFrom( 2 * MusicalTimeSpan.Eighth.Triplet(), 0, tempoMap); var note = new Note(NoteName.A, 4, length); notesManager.Notes.Add(note); } midiFile.Chunks.Add(trackChunk); midiFile.Write(\"Single note great song.mid\"); You can even build a musical composition: Pattern pattern = new PatternBuilder() // Insert a pause of 5 seconds .StepForward(new MetricTimeSpan(0, 0, 5)) // Insert an eighth C# note of the 4th octave .Note(Octave.Get(4).CSharp, MusicalTimeSpan.Eighth) // Set default note length to triplet eighth and default octave to 5 .SetNoteLength(MusicalTimeSpan.Eighth.Triplet()) .SetOctave(Octave.Get(5)) // Now we can add triplet eighth notes of the 5th octave in a simple way .Note(NoteName.A) .Note(NoteName.B) .Note(NoteName.GSharp) // Get pattern .Build(); MidiFile midiFile = pattern.ToFile(TempoMap.Default); DryWetMIDI provides devices API allowing to send MIDI events to and receive them from MIDI devices. Following example shows how to send events to MIDI device and handle them as they are received by the device: using System; using Melanchall.DryWetMidi.Multimedia; using Melanchall.DryWetMidi.Core; // ... using (var outputDevice = OutputDevice.GetByName(\"MIDI Device\")) { outputDevice.EventSent += OnEventSent; using (var inputDevice = InputDevice.GetByName(\"MIDI Device\")) { inputDevice.EventReceived += OnEventReceived; inputDevice.StartEventsListening(); outputDevice.SendEvent(new NoteOnEvent()); outputDevice.SendEvent(new NoteOffEvent()); } } // ... private void OnEventReceived(object sender, MidiEventReceivedEventArgs e) { var midiDevice = (MidiDevice)sender; Console.WriteLine($\"Event received from '{midiDevice.Name}' at {DateTime.Now}: {e.Event}\"); } private void OnEventSent(object sender, MidiEventSentEventArgs e) { var midiDevice = (MidiDevice)sender; Console.WriteLine($\"Event sent to '{midiDevice.Name}' at {DateTime.Now}: {e.Event}\"); }"
  },
  "obsolete/OBS1/description.html": {
    "href": "obsolete/OBS1/description.html",
    "title": "| DryWetMIDI",
    "keywords": "WritingSettings.CompressionPolicy has been replaced by corresponding properties of WritingSettings . No compression applied by default, as before. For example, to write using running status and write Note Off events as Note On ones with zero velocity we need to write: midiFile.Write(\"Great MIDI file.mid\", settings: new WritingSettings { UseRunningStatus = true, NoteOffAsSilentNoteOn = true });"
  },
  "obsolete/OBS1/new.html": {
    "href": "obsolete/OBS1/new.html",
    "title": "| DryWetMIDI",
    "keywords": "WritingSettings.DeleteDefaultKeySignature WritingSettings.DeleteDefaultSetTempo WritingSettings.DeleteDefaultTimeSignature WritingSettings.DeleteUnknownChunks WritingSettings.DeleteUnknownMetaEvents WritingSettings.NoteOffAsSilentNoteOn WritingSettings.UseRunningStatus"
  },
  "obsolete/OBS1/old.html": {
    "href": "obsolete/OBS1/old.html",
    "title": "| DryWetMIDI",
    "keywords": "WritingSettings.CompressionPolicy CompressionPolicy"
  },
  "obsolete/OBS10/description.html": {
    "href": "obsolete/OBS10/description.html",
    "title": "| DryWetMIDI",
    "keywords": "Randomizer tool is obsolete now. Randomization feature has been moved to Quantizer so you can quantize and randomize MIDI data at the same time. Following small example shows how to randomize timed events and start times of notes in range from -100 to +100 ticks: midiFile.QuantizeObjects( ObjectType.Note | ObjectType.TimedEvent, new ArbitraryGrid(), new QuantizingSettings { RandomizingSettings = new RandomizingSettings { Bounds = new ConstantBounds((MidiTimeSpan)100) } });"
  },
  "obsolete/OBS10/new.html": {
    "href": "obsolete/OBS10/new.html",
    "title": "| DryWetMIDI",
    "keywords": "Quantizer QuantizingSettings RandomizingSettings QuantizingSettings.RandomizingSettings QuantizerUtilities"
  },
  "obsolete/OBS10/old.html": {
    "href": "obsolete/OBS10/old.html",
    "title": "| DryWetMIDI",
    "keywords": "Randomizer<TObject, TSettings> RandomizingSettings<TObject> LengthedObjectsRandomizer<TObject, TSettings> LengthedObjectsRandomizingSettings<TObject> TimedEventsRandomizer NotesRandomizer ChordsRandomizer TimedEventsRandomizingSettings NotesRandomizingSettings ChordsRandomizingSettings TimedEventsRandomizerUtilities NotesRandomizerUtilities ChordsRandomizerUtilities"
  },
  "obsolete/OBS11/description.html": {
    "href": "obsolete/OBS11/description.html",
    "title": "| DryWetMIDI",
    "keywords": "Separate manager classes for each MIDI object type are replaced with TimedObjectsManager which can manage objects of different types simultaneously. For example, to manage just timed events : using (var objectsManager = new TimedObjectsManager(trackChunk.Events, ObjectType.TimedEvent)) { var firstTimedEvent = (TimedEvent)objectsManager.Objects.FirstOrDefault(); } or using (var objectsManager = new TimedObjectsManager<TimedEvent>(trackChunk.Events)) { var firstTimedEvent = objectsManager.Objects.FirstOrDefault(); } To manage both timed events and notes : using (var objectsManager = new TimedObjectsManager(trackChunk.Events, ObjectType.TimedEvent | ObjectType.Note)) { var firstObject = objectsManager.Objects.FirstOrDefault(); if (firstObject is Note note) { // do smth with note } else { // do smth with timed event } }"
  },
  "obsolete/OBS11/new.html": {
    "href": "obsolete/OBS11/new.html",
    "title": "| DryWetMIDI",
    "keywords": "TimedObjectsManager"
  },
  "obsolete/OBS11/old.html": {
    "href": "obsolete/OBS11/old.html",
    "title": "| DryWetMIDI",
    "keywords": "TimedEventsManager NotesManager ChordsManager"
  },
  "obsolete/OBS12/description.html": {
    "href": "obsolete/OBS12/description.html",
    "title": "| DryWetMIDI",
    "keywords": "Separate splitter classes for notes and chords have been replaced by Splitter class which can split objects of different types simultaneously. For example, to split notes and chords into 4 parts: midiFile.SplitObjectsByPartsNumber( ObjectType.Note | ObjectType.Chord, 4, TimeSpanType.Metric);"
  },
  "obsolete/OBS12/new.html": {
    "href": "obsolete/OBS12/new.html",
    "title": "| DryWetMIDI",
    "keywords": "Splitter Splitter.SplitObjectsByStep Splitter.SplitObjectsByGrid Splitter.SplitObjectsAtDistance Splitter.SplitObjectsByPartsNumber"
  },
  "obsolete/OBS12/old.html": {
    "href": "obsolete/OBS12/old.html",
    "title": "| DryWetMIDI",
    "keywords": "LengthedObjectsSplitter<TObject> ChordsSplitter NotesSplitter ChordsSplitterUtilities NotesSplitterUtilities"
  },
  "obsolete/OBS13/description.html": {
    "href": "obsolete/OBS13/description.html",
    "title": "| DryWetMIDI",
    "keywords": "Complex inheritance hierarchy of quantizer classes has been reduced to general-purpose new Quantizer class which can quantize objects of different types at the same time. More than that, it can quantize both start and end time simultaneously. For example, to quantize both ends of objects by the grid of 1/8 step: var quantizer = new Quantizer(); quantizer.Quantize( objects, new SteppedGrid(MusicalTimeSpan.Eighth), TempoMap.Default, new QuantizingSettings { Target = QuantizerTarget.Start | QuantizerTarget.End }); Of course, there is the new class with utility methods for quantizing objects within a MIDI file or track chunk - QuantizerUtilities . Following example shows how to quantize both ends of notes and chords by the grid of 1 second step within a MIDI file. We'll define a chord as a set of notes with minimum length of 2 : midiFile.QuantizeObjects( ObjectType.Note | ObjectType.Chord, new SteppedGrid(new MetricTimeSpan(0, 0, 1)), new QuantizingSettings { Target = QuantizerTarget.Start | QuantizerTarget.End }, new ObjectDetectionSettings { ChordDetectionSettings = new ChordDetectionSettings { NotesMinCount = 2 } });"
  },
  "obsolete/OBS13/new.html": {
    "href": "obsolete/OBS13/new.html",
    "title": "| DryWetMIDI",
    "keywords": "Quantizer QuantizingSettings QuantizerUtilities"
  },
  "obsolete/OBS13/old.html": {
    "href": "obsolete/OBS13/old.html",
    "title": "| DryWetMIDI",
    "keywords": "Quantizer<TObject, TSettings> QuantizingSettings<TObject> LengthedObjectsQuantizer<TObject, TSettings> LengthedObjectsQuantizingSettings<TObject> TimedEventsQuantizer NotesQuantizer ChordsQuantizer TimedEventsQuantizingSettings NotesQuantizingSettings ChordsQuantizingSettings TimedEventsQuantizerUtilities NotesQuantizerUtilities ChordsQuantizerUtilities"
  },
  "obsolete/OBS14/description.html": {
    "href": "obsolete/OBS14/description.html",
    "title": "| DryWetMIDI",
    "keywords": "TimedEventsManagingUtilities.SetTime method has been replaced with generic TimedObjectUtilities.SetTime allowing to set time for objects of different types, not for only timed events . Small example: timedEvent.SetTime(new BarBeatTicksTimeSpan(2), tempoMap); note.SetTime(MusicalTimeSpan.Half.SingleDotted(), tempoMap); chord.SetTime(new MetricTimeSpan(0, 1, 10), tempoMap);"
  },
  "obsolete/OBS14/new.html": {
    "href": "obsolete/OBS14/new.html",
    "title": "| DryWetMIDI",
    "keywords": "TimedObjectUtilities.SetTime"
  },
  "obsolete/OBS14/old.html": {
    "href": "obsolete/OBS14/old.html",
    "title": "| DryWetMIDI",
    "keywords": "TimedEventsManagingUtilities.SetTime"
  },
  "obsolete/OBS15/description.html": {
    "href": "obsolete/OBS15/description.html",
    "title": "| DryWetMIDI",
    "keywords": "SetTimeAndLength separate methods for notes and chords have been replaced with generic SetLength . Since SetTime method also exists, the new way to set time and length with one instruction is: note .SetTime(new MetricTimeSpan(0, 0, 0, 500), tempoMap) .SetLength(new MetricTimeSpan(0, 0, 10), tempoMap);"
  },
  "obsolete/OBS15/new.html": {
    "href": "obsolete/OBS15/new.html",
    "title": "| DryWetMIDI",
    "keywords": "LengthedObjectUtilities.SetLength"
  },
  "obsolete/OBS15/old.html": {
    "href": "obsolete/OBS15/old.html",
    "title": "| DryWetMIDI",
    "keywords": "NotesManagingUtilities.SetTimeAndLength* ChordsManagingUtilities.SetTimeAndLength*"
  },
  "obsolete/OBS16/description.html": {
    "href": "obsolete/OBS16/description.html",
    "title": "| DryWetMIDI",
    "keywords": "TimedEventsManagingUtilities.AddEvent methods are now obsolete since they are nothing more than just calling TimedEvent constructor and adding a new instance to a collection: eventsCollection.Add(new TimedEvent(midiEvent, time));"
  },
  "obsolete/OBS16/new.html": {
    "href": "obsolete/OBS16/new.html",
    "title": "| DryWetMIDI",
    "keywords": "no"
  },
  "obsolete/OBS16/old.html": {
    "href": "obsolete/OBS16/old.html",
    "title": "| DryWetMIDI",
    "keywords": "TimedEventsManagingUtilities.AddEvent"
  },
  "obsolete/OBS17/description.html": {
    "href": "obsolete/OBS17/description.html",
    "title": "| DryWetMIDI",
    "keywords": "NotesMerger class has been generalized by the Merger class which can merge objects of different types simultaneously. To merge objects within a collection of timed objects : var newObjects = objects.MergeObjects( TempoMap.Default, new ObjectsMergingSettings { Tolerance = new MetricTimeSpan(0, 0, 1) }); Quick example of how to merge notes within a MIDI file with the new tool: midiFile.MergeObjects( ObjectType.Note, new ObjectsMergingSettings { VelocityMergingPolicy = VelocityMergingPolicy.Max, Tolerance = (MidiTimeSpan)0 });"
  },
  "obsolete/OBS17/new.html": {
    "href": "obsolete/OBS17/new.html",
    "title": "| DryWetMIDI",
    "keywords": "Merger Merger.MergeObjects"
  },
  "obsolete/OBS17/old.html": {
    "href": "obsolete/OBS17/old.html",
    "title": "| DryWetMIDI",
    "keywords": "NotesMerger NotesMergerUtilities NotesMergingSettings"
  },
  "obsolete/OBS18/description.html": {
    "href": "obsolete/OBS18/description.html",
    "title": "| DryWetMIDI",
    "keywords": "ResizeNotesUtilities class and its methods have been generalized by the Resizer class which can resize groups of objects of different types simultaneously. Quick example of how to resize objects group using the new tool: objects.ResizeObjectsGroup( new MetricTimeSpan(0, 1, 0), TempoMap.Default, new ObjectsGroupResizingSettings { DistanceCalculationType = TimeSpanType.Metric });"
  },
  "obsolete/OBS18/new.html": {
    "href": "obsolete/OBS18/new.html",
    "title": "| DryWetMIDI",
    "keywords": "Resizer Resizer.ResizeObjectsGroup"
  },
  "obsolete/OBS18/old.html": {
    "href": "obsolete/OBS18/old.html",
    "title": "| DryWetMIDI",
    "keywords": "ResizeNotesUtilities"
  },
  "obsolete/OBS19/description.html": {
    "href": "obsolete/OBS19/description.html",
    "title": "| DryWetMIDI",
    "keywords": "Splitter.SplitByNotes method is now obsolere since it has been replaced by Splitter.SplitByObjects one which can split a MIDI file by objects of difefrent types and with more flexibility. Simple example of how to split a file by notes with the new tool: var newFiles = midiFile.SplitByObjects(ObjectType.Note); To split ignoring a note's channel: var newFiles = midiFile.SplitByObjects( ObjectType.Note, new SplitByObjectsSettings { KeySelector = obj => ObjectIdUtilities.GetObjectId(((Note)obj).NoteNumber) }); To split by notes with all other events transferred to each new file: var newFiles = midiFile.SplitByObjects( ObjectType.Note | ObjectType.TimedEvent, new SplitByObjectsSettings { KeySelector = obj => ObjectIdUtilities.GetObjectId(((Note)obj).NoteNumber), WriteToAllFilesPredicate = obj => obj is TimedEvent });"
  },
  "obsolete/OBS19/new.html": {
    "href": "obsolete/OBS19/new.html",
    "title": "| DryWetMIDI",
    "keywords": "Splitter.SplitByObjects"
  },
  "obsolete/OBS19/old.html": {
    "href": "obsolete/OBS19/old.html",
    "title": "| DryWetMIDI",
    "keywords": "Splitter.SplitByNotes"
  },
  "obsolete/OBS2/description.html": {
    "href": "obsolete/OBS2/description.html",
    "title": "| DryWetMIDI",
    "keywords": "Now MIDI file reading uses buffering by default so ReaderSettings.ReadFromMemory property is deprecated. By default buffering policy is BufferingPolicy.UseFixedSizeBuffer and BufferSize is 4096 which gives the same reading speed as putting all data in memory. But if you want, you can specify BufferingPolicy = BufferingPolicy.BufferAllData to achieve the same behavior as with ReadFromMemory : MidiFile.Read(\"Great MIDI file.mid\", new ReadingSettings { ReaderSettings = new ReaderSettings { BufferingPolicy = BufferingPolicy.BufferAllData } });"
  },
  "obsolete/OBS2/new.html": {
    "href": "obsolete/OBS2/new.html",
    "title": "| DryWetMIDI",
    "keywords": "ReaderSettings.BufferingPolicy BufferingPolicy BufferingPolicy.BufferAllData"
  },
  "obsolete/OBS2/old.html": {
    "href": "obsolete/OBS2/old.html",
    "title": "| DryWetMIDI",
    "keywords": "ReaderSettings.ReadFromMemory"
  },
  "obsolete/OBS3/description.html": {
    "href": "obsolete/OBS3/description.html",
    "title": "| DryWetMIDI",
    "keywords": "TempoMap.TimeSignature property has been replaced with more explicit and straightforward methods: GetTimeSignatureChanges and GetTimeSignatureAtTime : foreach (var timeSignatureChange in tempoMap.GetTimeSignatureChanges()) { var time = timeSignatureChange.Time; var timeSignature = timeSignatureChange.Value; } // ... tempoMap.GetTimeSignatureAtTime(MusicalTimeSpan.Whole);"
  },
  "obsolete/OBS3/new.html": {
    "href": "obsolete/OBS3/new.html",
    "title": "| DryWetMIDI",
    "keywords": "TempoMap.GetTimeSignatureChanges TempoMap.GetTimeSignatureAtTime"
  },
  "obsolete/OBS3/old.html": {
    "href": "obsolete/OBS3/old.html",
    "title": "| DryWetMIDI",
    "keywords": "TempoMap.TimeSignature"
  },
  "obsolete/OBS4/description.html": {
    "href": "obsolete/OBS4/description.html",
    "title": "| DryWetMIDI",
    "keywords": "TempoMap.Tempo property has been replaced with more explicit and straightforward methods: GetTempoChanges and GetTempoAtTime : foreach (var tempoChange in tempoMap.GetTempoChanges()) { var time = tempoChange.Time; var timeSignature = tempoChange.Value; } // ... tempoMap.GetTempoAtTime(MusicalTimeSpan.Whole);"
  },
  "obsolete/OBS4/new.html": {
    "href": "obsolete/OBS4/new.html",
    "title": "| DryWetMIDI",
    "keywords": "TempoMap.GetTempoChanges TempoMap.GetTempoAtTime"
  },
  "obsolete/OBS4/old.html": {
    "href": "obsolete/OBS4/old.html",
    "title": "| DryWetMIDI",
    "keywords": "TempoMap.Tempo"
  },
  "obsolete/OBS5/description.html": {
    "href": "obsolete/OBS5/description.html",
    "title": "| DryWetMIDI",
    "keywords": "Methods from GetTimedEventsAndNotesUtilities are now obsolete and you should use GetObjects methods from GetObjectsUtilities . Example how you can get timed events and notes: var timedEventsAndNotes = midiFile.GetObjects(ObjectType.TimedEvent | ObjectType.Note);"
  },
  "obsolete/OBS5/new.html": {
    "href": "obsolete/OBS5/new.html",
    "title": "| DryWetMIDI",
    "keywords": "GetObjectsUtilities"
  },
  "obsolete/OBS5/old.html": {
    "href": "obsolete/OBS5/old.html",
    "title": "| DryWetMIDI",
    "keywords": "GetTimedEventsAndNotesUtilities"
  },
  "obsolete/OBS6/description.html": {
    "href": "obsolete/OBS6/description.html",
    "title": "| DryWetMIDI",
    "keywords": "Methods from GetNotesAndRestsUtilities are now obsolete and you should use GetObjects methods from GetObjectsUtilities . Example how you can get notes and rests: var notesAndRests = midiFile.GetObjects(ObjectType.Note | ObjectType.Rest); RestSeparationPolicy can be specified via ObjectDetectionSettings : var notesAndRests = midiFile.GetObjects( ObjectType.Note | ObjectType.Rest, new ObjectDetectionSettings { RestDetectionSettings = new RestDetectionSettings { RestSeparationPolicy = RestSeparationPolicy.SeparateByChannel } });"
  },
  "obsolete/OBS6/new.html": {
    "href": "obsolete/OBS6/new.html",
    "title": "| DryWetMIDI",
    "keywords": "GetObjectsUtilities"
  },
  "obsolete/OBS6/old.html": {
    "href": "obsolete/OBS6/old.html",
    "title": "| DryWetMIDI",
    "keywords": "GetNotesAndRestsUtilities"
  },
  "obsolete/OBS7/description.html": {
    "href": "obsolete/OBS7/description.html",
    "title": "| DryWetMIDI",
    "keywords": "ToTrackChunk methods for collections of objects of one type (for example, collection of TimedEvent or Note instances) are replaced now with single TimedObjectUtilities.ToTrackChunk method which can save objects of different types to track chunk."
  },
  "obsolete/OBS7/new.html": {
    "href": "obsolete/OBS7/new.html",
    "title": "| DryWetMIDI",
    "keywords": "TimedObjectUtilities.ToTrackChunk"
  },
  "obsolete/OBS7/old.html": {
    "href": "obsolete/OBS7/old.html",
    "title": "| DryWetMIDI",
    "keywords": "TimedEventsManagingUtilities.ToTrackChunk NotesManagingUtilities.ToTrackChunk ChordsManagingUtilities.ToTrackChunk"
  },
  "obsolete/OBS8/description.html": {
    "href": "obsolete/OBS8/description.html",
    "title": "| DryWetMIDI",
    "keywords": "ToFile methods for collections of objects of one type (for example, collection of TimedEvent or Note instances) are replaced now with single TimedObjectUtilities.ToFile method which can save objects of different types to MIDI file."
  },
  "obsolete/OBS8/new.html": {
    "href": "obsolete/OBS8/new.html",
    "title": "| DryWetMIDI",
    "keywords": "TimedObjectUtilities.ToFile"
  },
  "obsolete/OBS8/old.html": {
    "href": "obsolete/OBS8/old.html",
    "title": "| DryWetMIDI",
    "keywords": "TimedEventsManagingUtilities.ToFile NotesManagingUtilities.ToFile ChordsManagingUtilities.ToFile"
  },
  "obsolete/OBS9/description.html": {
    "href": "obsolete/OBS9/description.html",
    "title": "| DryWetMIDI",
    "keywords": "AddTimedEvents , AddNotes and AddChords methods are replaced now with single TimedObjectUtilities.AddObjects method which can save objects of different types to events collection or track chunk."
  },
  "obsolete/OBS9/new.html": {
    "href": "obsolete/OBS9/new.html",
    "title": "| DryWetMIDI",
    "keywords": "TimedObjectUtilities.AddObjects"
  },
  "obsolete/OBS9/old.html": {
    "href": "obsolete/OBS9/old.html",
    "title": "| DryWetMIDI",
    "keywords": "TimedEventsManagingUtilities.AddTimedEvents NotesManagingUtilities.AddNotes ChordsManagingUtilities.AddChords"
  },
  "obsolete/obsolete.html": {
    "href": "obsolete/obsolete.html",
    "title": "Obsolete API | DryWetMIDI",
    "keywords": "Obsolete API Here the table of API that is obsolete and thus either will be removed from the library by a next release or already removed from the DryWetMIDI. Title of each obsolete API is just ID, please see description to see an old API and new replacement. OBS19 Splitter.SplitByNotes method is now obsolere since it has been replaced by Splitter.SplitByObjects one which can split a MIDI file by objects of difefrent types and with more flexibility. Simple example of how to split a file by notes with the new tool: var newFiles = midiFile.SplitByObjects(ObjectType.Note); To split ignoring a note's channel: var newFiles = midiFile.SplitByObjects( ObjectType.Note, new SplitByObjectsSettings { KeySelector = obj => ObjectIdUtilities.GetObjectId(((Note)obj).NoteNumber) }); To split by notes with all other events transferred to each new file: var newFiles = midiFile.SplitByObjects( ObjectType.Note | ObjectType.TimedEvent, new SplitByObjectsSettings { KeySelector = obj => ObjectIdUtilities.GetObjectId(((Note)obj).NoteNumber), WriteToAllFilesPredicate = obj => obj is TimedEvent }); Obsolete from version 6.1.1 . Old API Splitter.SplitByNotes New API Splitter.SplitByObjects OBS18 ResizeNotesUtilities class and its methods have been generalized by the Resizer class which can resize groups of objects of different types simultaneously. Quick example of how to resize objects group using the new tool: objects.ResizeObjectsGroup( new MetricTimeSpan(0, 1, 0), TempoMap.Default, new ObjectsGroupResizingSettings { DistanceCalculationType = TimeSpanType.Metric }); Obsolete from version 6.1.1 . Old API ResizeNotesUtilities New API Resizer Resizer.ResizeObjectsGroup OBS17 NotesMerger class has been generalized by the Merger class which can merge objects of different types simultaneously. To merge objects within a collection of timed objects : var newObjects = objects.MergeObjects( TempoMap.Default, new ObjectsMergingSettings { Tolerance = new MetricTimeSpan(0, 0, 1) }); Quick example of how to merge notes within a MIDI file with the new tool: midiFile.MergeObjects( ObjectType.Note, new ObjectsMergingSettings { VelocityMergingPolicy = VelocityMergingPolicy.Max, Tolerance = (MidiTimeSpan)0 }); Obsolete from version 6.1.1 . Old API NotesMerger NotesMergerUtilities NotesMergingSettings New API Merger Merger.MergeObjects OBS16 TimedEventsManagingUtilities.AddEvent methods are now obsolete since they are nothing more than just calling TimedEvent constructor and adding a new instance to a collection: eventsCollection.Add(new TimedEvent(midiEvent, time)); Obsolete from version 6.1.0 . Old API TimedEventsManagingUtilities.AddEvent New API no OBS15 SetTimeAndLength separate methods for notes and chords have been replaced with generic SetLength . Since SetTime method also exists, the new way to set time and length with one instruction is: note .SetTime(new MetricTimeSpan(0, 0, 0, 500), tempoMap) .SetLength(new MetricTimeSpan(0, 0, 10), tempoMap); Obsolete from version 6.1.0 . Old API NotesManagingUtilities.SetTimeAndLength* ChordsManagingUtilities.SetTimeAndLength* New API LengthedObjectUtilities.SetLength OBS14 TimedEventsManagingUtilities.SetTime method has been replaced with generic TimedObjectUtilities.SetTime allowing to set time for objects of different types, not for only timed events . Small example: timedEvent.SetTime(new BarBeatTicksTimeSpan(2), tempoMap); note.SetTime(MusicalTimeSpan.Half.SingleDotted(), tempoMap); chord.SetTime(new MetricTimeSpan(0, 1, 10), tempoMap); Obsolete from version 6.1.0 . Old API TimedEventsManagingUtilities.SetTime New API TimedObjectUtilities.SetTime OBS13 Complex inheritance hierarchy of quantizer classes has been reduced to general-purpose new Quantizer class which can quantize objects of different types at the same time. More than that, it can quantize both start and end time simultaneously. For example, to quantize both ends of objects by the grid of 1/8 step: var quantizer = new Quantizer(); quantizer.Quantize( objects, new SteppedGrid(MusicalTimeSpan.Eighth), TempoMap.Default, new QuantizingSettings { Target = QuantizerTarget.Start | QuantizerTarget.End }); Of course, there is the new class with utility methods for quantizing objects within a MIDI file or track chunk - QuantizerUtilities . Following example shows how to quantize both ends of notes and chords by the grid of 1 second step within a MIDI file. We'll define a chord as a set of notes with minimum length of 2 : midiFile.QuantizeObjects( ObjectType.Note | ObjectType.Chord, new SteppedGrid(new MetricTimeSpan(0, 0, 1)), new QuantizingSettings { Target = QuantizerTarget.Start | QuantizerTarget.End }, new ObjectDetectionSettings { ChordDetectionSettings = new ChordDetectionSettings { NotesMinCount = 2 } }); Obsolete from version 6.1.0 . Old API Quantizer<TObject, TSettings> QuantizingSettings<TObject> LengthedObjectsQuantizer<TObject, TSettings> LengthedObjectsQuantizingSettings<TObject> TimedEventsQuantizer NotesQuantizer ChordsQuantizer TimedEventsQuantizingSettings NotesQuantizingSettings ChordsQuantizingSettings TimedEventsQuantizerUtilities NotesQuantizerUtilities ChordsQuantizerUtilities New API Quantizer QuantizingSettings QuantizerUtilities OBS12 Separate splitter classes for notes and chords have been replaced by Splitter class which can split objects of different types simultaneously. For example, to split notes and chords into 4 parts: midiFile.SplitObjectsByPartsNumber( ObjectType.Note | ObjectType.Chord, 4, TimeSpanType.Metric); Obsolete from version 6.1.0 . Old API LengthedObjectsSplitter<TObject> ChordsSplitter NotesSplitter ChordsSplitterUtilities NotesSplitterUtilities New API Splitter Splitter.SplitObjectsByStep Splitter.SplitObjectsByGrid Splitter.SplitObjectsAtDistance Splitter.SplitObjectsByPartsNumber OBS11 Separate manager classes for each MIDI object type are replaced with TimedObjectsManager which can manage objects of different types simultaneously. For example, to manage just timed events : using (var objectsManager = new TimedObjectsManager(trackChunk.Events, ObjectType.TimedEvent)) { var firstTimedEvent = (TimedEvent)objectsManager.Objects.FirstOrDefault(); } or using (var objectsManager = new TimedObjectsManager<TimedEvent>(trackChunk.Events)) { var firstTimedEvent = objectsManager.Objects.FirstOrDefault(); } To manage both timed events and notes : using (var objectsManager = new TimedObjectsManager(trackChunk.Events, ObjectType.TimedEvent | ObjectType.Note)) { var firstObject = objectsManager.Objects.FirstOrDefault(); if (firstObject is Note note) { // do smth with note } else { // do smth with timed event } } Obsolete from version 6.1.0 . Old API TimedEventsManager NotesManager ChordsManager New API TimedObjectsManager OBS10 Randomizer tool is obsolete now. Randomization feature has been moved to Quantizer so you can quantize and randomize MIDI data at the same time. Following small example shows how to randomize timed events and start times of notes in range from -100 to +100 ticks: midiFile.QuantizeObjects( ObjectType.Note | ObjectType.TimedEvent, new ArbitraryGrid(), new QuantizingSettings { RandomizingSettings = new RandomizingSettings { Bounds = new ConstantBounds((MidiTimeSpan)100) } }); Obsolete from version 6.1.0 . Old API Randomizer<TObject, TSettings> RandomizingSettings<TObject> LengthedObjectsRandomizer<TObject, TSettings> LengthedObjectsRandomizingSettings<TObject> TimedEventsRandomizer NotesRandomizer ChordsRandomizer TimedEventsRandomizingSettings NotesRandomizingSettings ChordsRandomizingSettings TimedEventsRandomizerUtilities NotesRandomizerUtilities ChordsRandomizerUtilities New API Quantizer QuantizingSettings RandomizingSettings QuantizingSettings.RandomizingSettings QuantizerUtilities OBS9 Important API removed from the library by 6.0.0 release. AddTimedEvents , AddNotes and AddChords methods are replaced now with single TimedObjectUtilities.AddObjects method which can save objects of different types to events collection or track chunk. Obsolete from version 5.2.0 . Old API TimedEventsManagingUtilities.AddTimedEvents NotesManagingUtilities.AddNotes ChordsManagingUtilities.AddChords New API TimedObjectUtilities.AddObjects OBS8 Important API removed from the library by 6.0.0 release. ToFile methods for collections of objects of one type (for example, collection of TimedEvent or Note instances) are replaced now with single TimedObjectUtilities.ToFile method which can save objects of different types to MIDI file. Obsolete from version 5.2.0 . Old API TimedEventsManagingUtilities.ToFile NotesManagingUtilities.ToFile ChordsManagingUtilities.ToFile New API TimedObjectUtilities.ToFile OBS7 Important API removed from the library by 6.0.0 release. ToTrackChunk methods for collections of objects of one type (for example, collection of TimedEvent or Note instances) are replaced now with single TimedObjectUtilities.ToTrackChunk method which can save objects of different types to track chunk. Obsolete from version 5.2.0 . Old API TimedEventsManagingUtilities.ToTrackChunk NotesManagingUtilities.ToTrackChunk ChordsManagingUtilities.ToTrackChunk New API TimedObjectUtilities.ToTrackChunk OBS6 Important API removed from the library by 6.0.0 release. Methods from GetNotesAndRestsUtilities are now obsolete and you should use GetObjects methods from GetObjectsUtilities . Example how you can get notes and rests: var notesAndRests = midiFile.GetObjects(ObjectType.Note | ObjectType.Rest); RestSeparationPolicy can be specified via ObjectDetectionSettings : var notesAndRests = midiFile.GetObjects( ObjectType.Note | ObjectType.Rest, new ObjectDetectionSettings { RestDetectionSettings = new RestDetectionSettings { RestSeparationPolicy = RestSeparationPolicy.SeparateByChannel } }); Obsolete from version 5.2.0 . Old API GetNotesAndRestsUtilities New API GetObjectsUtilities OBS5 Important API removed from the library by 6.0.0 release. Methods from GetTimedEventsAndNotesUtilities are now obsolete and you should use GetObjects methods from GetObjectsUtilities . Example how you can get timed events and notes: var timedEventsAndNotes = midiFile.GetObjects(ObjectType.TimedEvent | ObjectType.Note); Obsolete from version 5.2.0 . Old API GetTimedEventsAndNotesUtilities New API GetObjectsUtilities OBS4 Important API removed from the library by 6.0.0 release. TempoMap.Tempo property has been replaced with more explicit and straightforward methods: GetTempoChanges and GetTempoAtTime : foreach (var tempoChange in tempoMap.GetTempoChanges()) { var time = tempoChange.Time; var timeSignature = tempoChange.Value; } // ... tempoMap.GetTempoAtTime(MusicalTimeSpan.Whole); Obsolete from version 5.1.2 . Old API TempoMap.Tempo New API TempoMap.GetTempoChanges TempoMap.GetTempoAtTime OBS3 Important API removed from the library by 6.0.0 release. TempoMap.TimeSignature property has been replaced with more explicit and straightforward methods: GetTimeSignatureChanges and GetTimeSignatureAtTime : foreach (var timeSignatureChange in tempoMap.GetTimeSignatureChanges()) { var time = timeSignatureChange.Time; var timeSignature = timeSignatureChange.Value; } // ... tempoMap.GetTimeSignatureAtTime(MusicalTimeSpan.Whole); Obsolete from version 5.1.2 . Old API TempoMap.TimeSignature New API TempoMap.GetTimeSignatureChanges TempoMap.GetTimeSignatureAtTime OBS2 Important API removed from the library by 6.0.0 release. Now MIDI file reading uses buffering by default so ReaderSettings.ReadFromMemory property is deprecated. By default buffering policy is BufferingPolicy.UseFixedSizeBuffer and BufferSize is 4096 which gives the same reading speed as putting all data in memory. But if you want, you can specify BufferingPolicy = BufferingPolicy.BufferAllData to achieve the same behavior as with ReadFromMemory : MidiFile.Read(\"Great MIDI file.mid\", new ReadingSettings { ReaderSettings = new ReaderSettings { BufferingPolicy = BufferingPolicy.BufferAllData } }); Obsolete from version 5.1.2 . Old API ReaderSettings.ReadFromMemory New API ReaderSettings.BufferingPolicy BufferingPolicy BufferingPolicy.BufferAllData OBS1 Important API removed from the library by 6.0.0 release. WritingSettings.CompressionPolicy has been replaced by corresponding properties of WritingSettings . No compression applied by default, as before. For example, to write using running status and write Note Off events as Note On ones with zero velocity we need to write: midiFile.Write(\"Great MIDI file.mid\", settings: new WritingSettings { UseRunningStatus = true, NoteOffAsSilentNoteOn = true }); Obsolete from version 5.1.2 . Old API WritingSettings.CompressionPolicy CompressionPolicy New API WritingSettings.DeleteDefaultKeySignature WritingSettings.DeleteDefaultSetTempo WritingSettings.DeleteDefaultTimeSignature WritingSettings.DeleteUnknownChunks WritingSettings.DeleteUnknownMetaEvents WritingSettings.NoteOffAsSilentNoteOn WritingSettings.UseRunningStatus"
  },
  "obsolete/template.html": {
    "href": "obsolete/template.html",
    "title": "$ID$ | DryWetMIDI",
    "keywords": "$ID$ $REMOVED$ $DESCRIPTION$ Obsolete from version $OBSOLETE_FROM_VERSION$ . Old API $OLD_API$ New API $NEW_API$"
  }
}